{
  "version": 3,
  "sources": ["../src/ssr/render.js", "../src/ssr/serialize.js", "../src/ssr/index.js", "../src/hooks/reactivity.js", "../src/ssr/hydrate.js", "../builds/ssr.js"],
  "sourcesContent": ["/**\n * SSR Rendering Module for Esor\n *\n * This module provides server-side rendering capabilities without relying on DOM APIs.\n * It converts Esor templates to HTML strings that can be sent to the client.\n */\n\nconst MARKER = \"\\uFEFF\";\nconst SSR_SIGNAL_ATTR = \"data-esor-signal\";\nconst SSR_HANDLER_ATTR = \"data-esor-handler\";\n\n/**\n * State tracker for SSR - collects all signal values encountered during rendering\n */\nclass SSRStateTracker {\n    constructor() {\n        this.signals = new Map(); // id -> value\n        this.nextId = 0;\n    }\n\n    trackSignal(signal) {\n        if (!this.signals.has(signal)) {\n            const id = `s${this.nextId++}`;\n            this.signals.set(signal, { id, value: signal() });\n            return id;\n        }\n        return this.signals.get(signal).id;\n    }\n\n    getState() {\n        const state = {};\n        for (const [signal, { id, value }] of this.signals) {\n            state[id] = value;\n        }\n        return state;\n    }\n}\n\n/**\n * Creates a template object for SSR (similar to client-side html``)\n *\n * @param {TemplateStringsArray} strings - Template strings with placeholders\n * @param {...any} values - Values to be inserted into the template\n * @returns {object} Template object for SSR rendering\n */\nconst html = (strings, ...values) => {\n    const keyAttrIndex = strings.findIndex((s) => s.trim().endsWith(\"key=\"));\n\n    let key;\n    let otherValues = [...values];\n    if (keyAttrIndex !== -1) {\n        key = values[keyAttrIndex];\n        otherValues.splice(keyAttrIndex, 1);\n    }\n\n    return {\n        strings,\n        values: otherValues,\n        _isTemplate: true,\n        _key: key,\n        _isSSR: true\n    };\n};\n\n/**\n * Escapes HTML special characters\n */\nconst escapeHtml = (str) => {\n    if (str == null) return '';\n    return String(str)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#39;');\n};\n\n/**\n * Renders a value to HTML string\n *\n * @param {any} value - The value to render\n * @param {SSRStateTracker} tracker - State tracker for signals\n * @returns {string} HTML string\n */\nconst renderValue = (value, tracker) => {\n    // Handle null, undefined, false\n    if (value == null || value === false) {\n        return '';\n    }\n\n    // Handle arrays\n    if (Array.isArray(value)) {\n        return value.map(v => renderValue(v, tracker)).join('');\n    }\n\n    // Handle templates\n    if (value._isTemplate) {\n        return renderTemplate(value, tracker);\n    }\n\n    // Handle signals - extract value and track for hydration\n    if (value._isSignal) {\n        const signalId = tracker.trackSignal(value);\n        const actualValue = value();\n        // Return the current value, marker will be added by attribute handling\n        return escapeHtml(actualValue);\n    }\n\n    // Handle functions - execute them in SSR context\n    if (typeof value === 'function') {\n        return renderValue(value(), tracker);\n    }\n\n    // Handle primitives\n    return escapeHtml(value);\n};\n\n/**\n * Processes attribute values for SSR\n *\n * @param {string} name - Attribute name\n * @param {any} value - Attribute value\n * @param {SSRStateTracker} tracker - State tracker\n * @returns {string} HTML attribute string\n */\nconst renderAttribute = (name, value, tracker) => {\n    // Skip ref attributes in SSR\n    if (name === 'ref') {\n        return '';\n    }\n\n    // Handle event handlers - store for hydration\n    if (name.startsWith('on')) {\n        const eventName = name.slice(2).toLowerCase();\n        return ` ${SSR_HANDLER_ATTR}=\"${eventName}\"`;\n    }\n\n    // Handle style objects\n    if (name === 'style' && typeof value === 'object' && !Array.isArray(value)) {\n        const styleStr = Object.entries(value)\n            .map(([k, v]) => `${k.replace(/[A-Z]/g, m => '-' + m.toLowerCase())}:${v}`)\n            .join(';');\n        return ` style=\"${escapeHtml(styleStr)}\"`;\n    }\n\n    // Handle signals in attributes\n    if (value?._isSignal) {\n        const signalId = tracker.trackSignal(value);\n        const actualValue = value();\n\n        if (name === 'value' || name === 'checked' || name === 'selected') {\n            // For form elements, set both attribute and add signal marker\n            return ` ${name}=\"${escapeHtml(actualValue)}\" ${SSR_SIGNAL_ATTR}=\"${signalId}:${name}\"`;\n        }\n\n        if (actualValue == null || actualValue === false) {\n            return ` ${SSR_SIGNAL_ATTR}=\"${signalId}:${name}\"`;\n        }\n\n        return ` ${name}=\"${escapeHtml(actualValue === true ? '' : actualValue)}\" ${SSR_SIGNAL_ATTR}=\"${signalId}:${name}\"`;\n    }\n\n    // Handle functions in attributes\n    if (typeof value === 'function') {\n        return renderAttribute(name, value(), tracker);\n    }\n\n    // Handle boolean attributes\n    if (value === true) {\n        return ` ${name}`;\n    }\n\n    if (value === false || value == null) {\n        return '';\n    }\n\n    // Handle special form element properties\n    if (name === 'value' || name === 'checked' || name === 'selected') {\n        return ` ${name}=\"${escapeHtml(value)}\"`;\n    }\n\n    // Regular attributes\n    return ` ${name}=\"${escapeHtml(value)}\"`;\n};\n\n/**\n * Renders a template to HTML string\n *\n * @param {object} templateObj - Template object with strings and values\n * @param {SSRStateTracker} tracker - State tracker for signals\n * @returns {string} HTML string\n */\nconst renderTemplate = (templateObj, tracker) => {\n    const { strings, values } = templateObj;\n    let html = '';\n    let valueIndex = 0;\n\n    for (let i = 0; i < strings.length; i++) {\n        const str = strings[i];\n\n        // Add the static string part\n        html += str.replace(MARKER, '');\n\n        // Add the dynamic value if we're not at the end\n        if (i < values.length) {\n            const value = values[valueIndex++];\n\n            // Check if this is an attribute value (previous string ends with =)\n            const isAttribute = str.trimEnd().endsWith('=');\n\n            if (isAttribute) {\n                // Extract attribute name\n                const attrMatch = str.match(/\\s+(\\w+(?:-\\w+)*)=$/);\n                if (attrMatch) {\n                    const attrName = attrMatch[1];\n                    // Remove the = we already added\n                    html = html.slice(0, -1);\n                    html += renderAttribute(attrName, value, tracker);\n                }\n            } else {\n                // Text content\n                if (value?._isSignal) {\n                    const signalId = tracker.trackSignal(value);\n                    const actualValue = value();\n                    html += `<span ${SSR_SIGNAL_ATTR}=\"${signalId}:text\">${escapeHtml(actualValue)}</span>`;\n                } else if (typeof value === 'function') {\n                    const result = value();\n                    if (result?._isSignal) {\n                        const signalId = tracker.trackSignal(result);\n                        const actualValue = result();\n                        html += `<span ${SSR_SIGNAL_ATTR}=\"${signalId}:text\">${escapeHtml(actualValue)}</span>`;\n                    } else {\n                        html += renderValue(result, tracker);\n                    }\n                } else {\n                    html += renderValue(value, tracker);\n                }\n            }\n        }\n    }\n\n    return html;\n};\n\n/**\n * Renders a template to an HTML string with state\n *\n * @param {object} template - The template object to render\n * @returns {{ html: string, state: object }} Object containing HTML and state for hydration\n */\nconst renderToString = (template) => {\n    if (!template || !template._isTemplate) {\n        throw new Error('renderToString expects a template created with html``');\n    }\n\n    const tracker = new SSRStateTracker();\n    const htmlString = renderTemplate(template, tracker);\n    const state = tracker.getState();\n\n    return { html: htmlString, state };\n};\n\nexport { html, renderToString, renderValue, renderTemplate };\n", "/**\n * State Serialization for SSR\n *\n * This module handles serialization of application state for hydration on the client.\n */\n\nconst STATE_SCRIPT_ID = '__ESOR_STATE__';\n\n/**\n * Safely serializes a value to JSON, handling special cases\n *\n * @param {any} value - The value to serialize\n * @returns {string} JSON string\n */\nconst serializeValue = (value) => {\n    if (value === undefined) return 'undefined';\n    if (value === null) return 'null';\n    if (typeof value === 'function') return 'null'; // Can't serialize functions\n    if (typeof value === 'symbol') return 'null'; // Can't serialize symbols\n\n    // Handle dates\n    if (value instanceof Date) {\n        return JSON.stringify({ __type: 'Date', value: value.toISOString() });\n    }\n\n    // Handle regular expressions\n    if (value instanceof RegExp) {\n        return JSON.stringify({ __type: 'RegExp', source: value.source, flags: value.flags });\n    }\n\n    // Handle arrays\n    if (Array.isArray(value)) {\n        return '[' + value.map(serializeValue).join(',') + ']';\n    }\n\n    // Handle objects\n    if (typeof value === 'object') {\n        const pairs = [];\n        for (const key in value) {\n            if (Object.prototype.hasOwnProperty.call(value, key)) {\n                pairs.push(JSON.stringify(key) + ':' + serializeValue(value[key]));\n            }\n        }\n        return '{' + pairs.join(',') + '}';\n    }\n\n    // Primitives (string, number, boolean)\n    return JSON.stringify(value);\n};\n\n/**\n * Deserializes a value, handling special types\n *\n * @param {any} value - The value to deserialize\n * @returns {any} Deserialized value\n */\nconst deserializeValue = (value) => {\n    if (value === null || value === undefined) return value;\n\n    // Handle special types\n    if (typeof value === 'object') {\n        if (value.__type === 'Date') {\n            return new Date(value.value);\n        }\n        if (value.__type === 'RegExp') {\n            return new RegExp(value.source, value.flags);\n        }\n\n        // Recursively deserialize objects and arrays\n        if (Array.isArray(value)) {\n            return value.map(deserializeValue);\n        }\n\n        const result = {};\n        for (const key in value) {\n            if (Object.prototype.hasOwnProperty.call(value, key)) {\n                result[key] = deserializeValue(value[key]);\n            }\n        }\n        return result;\n    }\n\n    return value;\n};\n\n/**\n * Creates a script tag with serialized state for hydration\n *\n * @param {object} state - The state object to serialize\n * @returns {string} HTML script tag with state\n */\nconst createStateScript = (state) => {\n    const serialized = serializeValue(state);\n    return `<script id=\"${STATE_SCRIPT_ID}\" type=\"application/json\">${serialized}</script>`;\n};\n\n/**\n * Retrieves and deserializes state from the page (client-side only)\n *\n * @returns {object|null} Deserialized state or null if not found\n */\nconst getStateFromPage = () => {\n    if (typeof document === 'undefined') {\n        return null;\n    }\n\n    const script = document.getElementById(STATE_SCRIPT_ID);\n    if (!script) {\n        return null;\n    }\n\n    try {\n        const state = JSON.parse(script.textContent);\n        return deserializeValue(state);\n    } catch (e) {\n        console.error('Failed to parse SSR state:', e);\n        return null;\n    }\n};\n\n/**\n * Injects state script into HTML string\n *\n * @param {string} html - The HTML string\n * @param {object} state - The state to inject\n * @param {string} position - Where to inject ('head' or 'body', default 'body')\n * @returns {string} HTML with injected state\n */\nconst injectState = (html, state, position = 'body') => {\n    const stateScript = createStateScript(state);\n\n    if (position === 'head') {\n        // Inject before closing </head>\n        return html.replace('</head>', `${stateScript}\\n</head>`);\n    }\n\n    // Inject before closing </body> or at the end\n    if (html.includes('</body>')) {\n        return html.replace('</body>', `${stateScript}\\n</body>`);\n    }\n\n    return html + stateScript;\n};\n\nexport {\n    serializeValue,\n    deserializeValue,\n    createStateScript,\n    getStateFromPage,\n    injectState,\n    STATE_SCRIPT_ID\n};\n", "/**\n * Esor SSR (Server-Side Rendering) Module\n *\n * This module provides server-side rendering and hydration capabilities for Esor.\n *\n * @module esor/ssr\n *\n * @example\n * // Server-side (Node.js)\n * import { renderToString, injectState } from 'esor/ssr';\n * import { html, signal } from 'esor/ssr';\n *\n * const count = signal(0);\n * const template = html`<div>Count: ${count}</div>`;\n * const { html: htmlString, state } = renderToString(template);\n * const fullHtml = injectState(htmlString, state);\n *\n * @example\n * // Client-side (Browser)\n * import { hydrate } from 'esor/ssr';\n * import { signal } from 'esor';\n *\n * const count = signal(0);\n * hydrate('#app', {\n *   signals: { s0: count }\n * });\n */\n\n// Server-side rendering\nexport { html, renderToString } from './render.js';\n\n// State serialization\nexport {\n    createStateScript,\n    injectState,\n    serializeValue,\n    deserializeValue\n} from './serialize.js';\n\n// Client-side hydration\nexport {\n    hydrate,\n    createHydratableComponent,\n    isSSRContent\n} from './hydrate.js';\n\n// Enhanced API (recommended for new projects)\nexport {\n    defineComponent,\n    createSSRComponent,\n    renderComponent,\n    hydrateComponent,\n    render,\n    signal,\n    computed,\n    handler\n} from './enhanced-api.js';\n\n// Import for renderToHTML helper\nimport { renderToString as _renderToString } from './render.js';\nimport { injectState as _injectState } from './serialize.js';\n\n/**\n * Helper function to render a full HTML page with SSR content\n *\n * @param {object} template - The template to render\n * @param {object} options - Rendering options\n * @param {string} [options.title='Esor App'] - Page title\n * @param {string} [options.lang='en'] - HTML lang attribute\n * @param {string} [options.head=''] - Additional head content\n * @param {string} [options.bodyAttrs=''] - Additional body attributes\n * @returns {string} Complete HTML document\n */\nexport const renderToHTML = (template, options = {}) => {\n    const {\n        title = 'Esor App',\n        lang = 'en',\n        head = '',\n        bodyAttrs = ''\n    } = options;\n\n    const { html: content, state } = _renderToString(template);\n\n    const htmlDoc = `<!DOCTYPE html>\n<html lang=\"${lang}\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${title}</title>\n    ${head}\n</head>\n<body${bodyAttrs ? ' ' + bodyAttrs : ''}>\n    ${content}\n</body>\n</html>`;\n\n    return _injectState(htmlDoc, state, 'body');\n};\n\n/**\n * Stream renderer for SSR (for large applications)\n *\n * @param {object} template - The template to render\n * @returns {ReadableStream} Stream of HTML chunks\n */\nexport const renderToStream = (template) => {\n    // Import locally\n    const { renderToString } = require('./render.js');\n\n    return new ReadableStream({\n        start(controller) {\n            try {\n                const { html, state } = renderToString(template);\n\n                // Encode and enqueue the HTML\n                const encoder = new TextEncoder();\n                controller.enqueue(encoder.encode(html));\n\n                // Add state script at the end\n                const { createStateScript } = require('./serialize.js');\n                controller.enqueue(encoder.encode(createStateScript(state)));\n\n                controller.close();\n            } catch (error) {\n                controller.error(error);\n            }\n        }\n    });\n};\n", "let currentEffect = null;\nlet batchDepth = 0;\nlet pendingEffects = null;\nlet autoBatchScheduled = false;\n\n/**\n * Executes all pending effects and resets the auto-batch flag.\n * Continues flushing until no more effects are pending (to handle cascading updates).\n * @private\n */\nfunction flushEffects() {\n    autoBatchScheduled = false;\n    while (pendingEffects) {\n        const effects = pendingEffects;\n        pendingEffects = null;\n        for (const fn of effects) fn();\n    }\n}\n\n/**\n * Creates a reactive signal that notifies its subscribers when its value changes.\n *\n * Signals are reactive values that can be used to track state changes in your application.\n * When the signal's value is changed, all subscribed functions will be called with the new value.\n * Subscribers can be added either by calling the signal with no arguments (which will add the\n * current effect to the subscribers) or by calling the signal with a new value.\n *\n * @param {*} initialValue - The initial value of the signal.\n * @returns {Function} A function that can be used to get or set the signal's value.\n */\nconst signal = (initialValue) => {\n    let value = initialValue;\n    const subscribers = new Set();\n\n    const signalFn = (...args) => {\n        if (!args.length) {\n            currentEffect && subscribers.add(currentEffect);\n            return value;\n        }\n\n        const newValue = args[0];\n        if (value !== newValue) {\n            value = newValue;\n            if (batchDepth) {\n                // Manual batch is active (higher priority)\n                pendingEffects ||= new Set();\n                for (const fn of subscribers) pendingEffects.add(fn);\n            } else {\n                // Auto-batching with microtask\n                pendingEffects ||= new Set();\n                for (const fn of subscribers) pendingEffects.add(fn);\n\n                if (!autoBatchScheduled) {\n                    autoBatchScheduled = true;\n                    queueMicrotask(flushEffects);\n                }\n            }\n        }\n\n        return value;\n    };\n\n    // Mark as signal for template detection\n    signalFn._isSignal = true;\n\n    return signalFn;\n};\n\n/**\n * Creates an effect that runs a function and remembers it for future calls.\n *\n * Effects are functions that run a computation and remember themselves for\n * future calls. When an effect is called, it sets itself as the current effect\n * and then calls the computation. After the computation is done, it sets the\n * current effect back to null.\n *\n * @param {Function} fn - The computation to run.\n * @returns {Function} The effect function.\n */\nconst effect = (fn) => {\n    const execute = () => {\n        currentEffect = execute;\n        fn();\n        currentEffect = null;\n    };\n    execute();\n    return execute;\n};\n\n/**\n * Creates a computed signal that automatically updates based on its dependencies.\n *\n * A computed signal is a derived value that updates whenever the signals it depends\n * on change. When the provided function is executed, it tracks the dependencies,\n * and any changes to those dependencies will cause the computed function to re-run,\n * updating the computed signal's value.\n *\n * @param {Function} fn - The function that returns the computed value, which may depend\n * on other reactive signals.\n * @returns {Function} A signal function that returns the current computed value.\n */\n\nconst computed = (fn) => {\n    const result = signal(undefined);\n    effect(() => result(fn()));\n    return result;\n};\n\n/**\n * Runs a function without scheduling subscriber updates until all batches are complete.\n *\n * Batching is useful when you need to update multiple reactive signals\n * without notifying their subscribers until all updates are complete.\n * This can be useful for performance optimization.\n *\n * @param {Function} fn - The function to run in batch mode.\n * @returns {*} The result of the function.\n */\nconst batch = (fn) => {\n    batchDepth++;\n    const result = fn();\n    if (!--batchDepth && pendingEffects) {\n        flushEffects();\n    }\n    return result;\n};\n\n/**\n * Executes a function and immediately flushes all pending effects synchronously.\n *\n * This is useful when you need to ensure that all effects run immediately,\n * bypassing the auto-batching mechanism. This can be important for cases\n * where you need to read DOM measurements or perform operations that depend\n * on the effects having already run.\n *\n * @param {Function} fn - The function to execute.\n * @returns {*} The result of the function.\n */\nconst flushSync = (fn) => {\n    batchDepth++;\n    const result = fn();\n    batchDepth--;\n    if (pendingEffects) {\n        flushEffects();\n    }\n    return result;\n};\n\nexport { signal, effect, computed, batch, flushSync };\n", "/**\n * Client-side Hydration for SSR\n *\n * This module activates reactivity on server-rendered content.\n */\n\nimport { effect } from '../hooks/reactivity.js';\nimport { getStateFromPage } from './serialize.js';\n\nconst SSR_SIGNAL_ATTR = 'data-esor-signal';\nconst SSR_HANDLER_ATTR = 'data-esor-handler';\n\n/**\n * Hydrates a DOM element with reactive signals\n *\n * @param {HTMLElement} root - The root element to hydrate\n * @param {object} signalMap - Map of signal IDs to signal functions\n * @param {object} state - Initial state from SSR\n */\nconst hydrateElement = (root, signalMap, state) => {\n    // Find all elements with signal markers\n    const signalElements = root.querySelectorAll(`[${SSR_SIGNAL_ATTR}]`);\n\n    for (const element of signalElements) {\n        const signalData = element.getAttribute(SSR_SIGNAL_ATTR);\n        const [signalId, bindType] = signalData.split(':');\n\n        const signal = signalMap[signalId];\n        if (!signal) {\n            console.warn(`Signal ${signalId} not found in signal map`);\n            continue;\n        }\n\n        // Initialize signal with SSR value if available\n        if (state && signalId in state) {\n            signal(state[signalId]);\n        }\n\n        // Set up reactive binding based on type\n        if (bindType === 'text') {\n            // Text content binding\n            effect(() => {\n                element.textContent = signal();\n            });\n        } else {\n            // Attribute binding\n            effect(() => {\n                const value = signal();\n\n                if (bindType === 'value' || bindType === 'checked' || bindType === 'selected') {\n                    // Form element properties\n                    element[bindType] = value;\n                } else if (value == null || value === false) {\n                    // Remove attribute for falsy values\n                    element.removeAttribute(bindType);\n                } else {\n                    // Set attribute\n                    element.setAttribute(bindType, value === true ? '' : value);\n                }\n            });\n        }\n\n        // Clean up the hydration marker\n        element.removeAttribute(SSR_SIGNAL_ATTR);\n    }\n};\n\n/**\n * Hydrates event handlers on elements\n *\n * @param {HTMLElement} root - The root element to hydrate\n * @param {object} handlerMap - Map of event names to handler functions\n */\nconst hydrateEventHandlers = (root, handlerMap) => {\n    if (!handlerMap) return;\n\n    const handlerElements = root.querySelectorAll(`[${SSR_HANDLER_ATTR}]`);\n\n    for (const element of handlerElements) {\n        const eventName = element.getAttribute(SSR_HANDLER_ATTR);\n        const handler = handlerMap[eventName];\n\n        if (handler && typeof handler === 'function') {\n            element.addEventListener(eventName, handler);\n\n            // Store cleanup function\n            if (!element._cleanup) {\n                element._cleanup = () => element.removeEventListener(eventName, handler);\n            }\n        }\n\n        // Clean up the hydration marker\n        element.removeAttribute(SSR_HANDLER_ATTR);\n    }\n};\n\n/**\n * Main hydration function - activates reactivity on SSR content\n *\n * @param {HTMLElement|string} target - Root element or selector to hydrate\n * @param {object} options - Hydration options\n * @param {object} options.signals - Map of signal IDs to signal functions\n * @param {object} [options.handlers] - Map of event names to handler functions\n * @param {object} [options.state] - Initial state (if not auto-detected)\n * @returns {void}\n */\nconst hydrate = (target, options = {}) => {\n    // Resolve target element\n    const root = typeof target === 'string'\n        ? document.querySelector(target)\n        : target;\n\n    if (!root) {\n        throw new Error(`Hydration target not found: ${target}`);\n    }\n\n    // Get state from page if not provided\n    const state = options.state ?? getStateFromPage();\n\n    // Hydrate signals\n    if (options.signals) {\n        hydrateElement(root, options.signals, state);\n    }\n\n    // Hydrate event handlers\n    if (options.handlers) {\n        hydrateEventHandlers(root, options.handlers);\n    }\n};\n\n/**\n * Creates a hydration-ready component wrapper\n *\n * This function wraps a component setup function to make it hydration-aware.\n * It will skip initial rendering if SSR content is detected and instead hydrate the existing DOM.\n *\n * @param {Function} setupFn - The component setup function\n * @returns {Function} Hydration-aware setup function\n */\nconst createHydratableComponent = (setupFn) => {\n    return function(props) {\n        const template = setupFn.call(this, props);\n\n        // Check if we're in a hydration scenario\n        const isHydrating = this.shadowRoot?.querySelector(`[${SSR_SIGNAL_ATTR}]`) !== undefined;\n\n        if (isHydrating) {\n            // Extract signals from template for hydration\n            // This requires the component to expose its signals\n            if (this._signals) {\n                const state = getStateFromPage();\n                hydrateElement(this.shadowRoot, this._signals, state);\n            }\n\n            // Return the template but skip re-rendering\n            // The existing DOM will be hydrated instead\n            return template;\n        }\n\n        // Normal client-side rendering\n        return template;\n    };\n};\n\n/**\n * Checks if the current page contains SSR content\n *\n * @returns {boolean} True if SSR content is detected\n */\nconst isSSRContent = () => {\n    if (typeof document === 'undefined') {\n        return false;\n    }\n\n    return document.querySelector(`[${SSR_SIGNAL_ATTR}]`) !== null ||\n           getStateFromPage() !== null;\n};\n\nexport {\n    hydrate,\n    hydrateElement,\n    hydrateEventHandlers,\n    createHydratableComponent,\n    isSSRContent\n};\n", "/**\n * SSR Build Entry Point\n *\n * This file exports all SSR-related functionality for server-side rendering.\n * Use this in Node.js environments.\n */\n\nexport { html, renderToString, renderToHTML, renderToStream } from '../src/ssr/index.js';\nexport { createStateScript, injectState, serializeValue, deserializeValue } from '../src/ssr/serialize.js';\nexport { hydrate, createHydratableComponent, isSSRContent } from '../src/ssr/hydrate.js';\n\n// Re-export core reactivity for convenience\nexport { signal, effect, computed, batch, flushSync } from '../src/hooks/reactivity.js';\n"],
  "mappings": "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",
  "names": ["render_exports", "__export", "html", "renderTemplate", "renderToString", "renderValue", "MARKER", "SSR_SIGNAL_ATTR", "SSR_HANDLER_ATTR", "SSRStateTracker", "escapeHtml", "renderAttribute", "init_render", "__esmMin", "signal", "id", "state", "value", "strings", "values", "keyAttrIndex", "s", "key", "otherValues", "str", "tracker", "v", "signalId", "actualValue", "name", "eventName", "styleStr", "k", "m", "templateObj", "valueIndex", "attrMatch", "attrName", "result", "template", "htmlString", "serialize_exports", "__export", "STATE_SCRIPT_ID", "createStateScript", "deserializeValue", "getStateFromPage", "injectState", "serializeValue", "init_serialize", "__esmMin", "value", "pairs", "key", "result", "state", "serialized", "script", "html", "position", "stateScript", "init_render", "currentEffect", "batchDepth", "pendingEffects", "autoBatchScheduled", "flushEffects", "effects", "fn", "signal", "initialValue", "value", "subscribers", "signalFn", "args", "newValue", "effect", "execute", "computed", "result", "batch", "flushSync", "init_serialize", "SSR_SIGNAL_ATTR", "SSR_HANDLER_ATTR", "hydrateElement", "root", "signalMap", "state", "signalElements", "element", "signalData", "signalId", "bindType", "signal", "effect", "value", "hydrateEventHandlers", "handlerMap", "handlerElements", "eventName", "handler", "hydrate", "target", "options", "getStateFromPage", "createHydratableComponent", "setupFn", "props", "template", "isSSRContent", "init_render", "init_serialize", "renderToHTML", "template", "options", "title", "lang", "head", "bodyAttrs", "content", "state", "renderToString", "htmlDoc", "injectState", "renderToStream", "controller", "html", "encoder", "createStateScript", "error", "init_serialize"]
}
