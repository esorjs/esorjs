{
  "version": 3,
  "sources": ["../src/hooks/reactivity.js", "../src/template/reconcile.js", "../src/template/render.js", "../src/lifecycle.js", "../src/props.js", "../src/utils/dom.js", "../src/component.js", "../src/hooks/ref.js", "../src/hooks/emit.js"],
  "sourcesContent": ["let currentEffect = null;\nlet batchDepth = 0;\nlet pendingEffects = null;\nlet autoBatchScheduled = false;\n\n/**\n * Executes all pending effects and resets the auto-batch flag.\n * Continues flushing until no more effects are pending (to handle cascading updates).\n * @private\n */\nfunction flushEffects() {\n    autoBatchScheduled = false;\n    while (pendingEffects) {\n        const effects = pendingEffects;\n        pendingEffects = null;\n        for (const fn of effects) fn();\n    }\n}\n\n/**\n * Creates a reactive signal that notifies its subscribers when its value changes.\n *\n * Signals are reactive values that can be used to track state changes in your application.\n * When the signal's value is changed, all subscribed functions will be called with the new value.\n * Subscribers can be added either by calling the signal with no arguments (which will add the\n * current effect to the subscribers) or by calling the signal with a new value.\n *\n * @param {*} initialValue - The initial value of the signal.\n * @returns {Function} A function that can be used to get or set the signal's value.\n */\nconst signal = (initialValue) => {\n    let value = initialValue;\n    const subscribers = new Set();\n\n    return (...args) => {\n        if (!args.length) {\n            currentEffect && subscribers.add(currentEffect);\n            return value;\n        }\n\n        const newValue = args[0];\n        if (value !== newValue) {\n            value = newValue;\n            if (batchDepth) {\n                // Manual batch is active (higher priority)\n                pendingEffects ||= new Set();\n                for (const fn of subscribers) pendingEffects.add(fn);\n            } else {\n                // Auto-batching with microtask\n                pendingEffects ||= new Set();\n                for (const fn of subscribers) pendingEffects.add(fn);\n\n                if (!autoBatchScheduled) {\n                    autoBatchScheduled = true;\n                    queueMicrotask(flushEffects);\n                }\n            }\n        }\n\n        return value;\n    };\n};\n\n/**\n * Creates an effect that runs a function and remembers it for future calls.\n *\n * Effects are functions that run a computation and remember themselves for\n * future calls. When an effect is called, it sets itself as the current effect\n * and then calls the computation. After the computation is done, it sets the\n * current effect back to null.\n *\n * @param {Function} fn - The computation to run.\n * @returns {Function} The effect function.\n */\nconst effect = (fn) => {\n    const execute = () => {\n        currentEffect = execute;\n        fn();\n        currentEffect = null;\n    };\n    execute();\n    return execute;\n};\n\n/**\n * Creates a computed signal that automatically updates based on its dependencies.\n *\n * A computed signal is a derived value that updates whenever the signals it depends\n * on change. When the provided function is executed, it tracks the dependencies,\n * and any changes to those dependencies will cause the computed function to re-run,\n * updating the computed signal's value.\n *\n * @param {Function} fn - The function that returns the computed value, which may depend\n * on other reactive signals.\n * @returns {Function} A signal function that returns the current computed value.\n */\n\nconst computed = (fn) => {\n    const result = signal(undefined);\n    effect(() => result(fn()));\n    return result;\n};\n\n/**\n * Runs a function without scheduling subscriber updates until all batches are complete.\n *\n * Batching is useful when you need to update multiple reactive signals\n * without notifying their subscribers until all updates are complete.\n * This can be useful for performance optimization.\n *\n * @param {Function} fn - The function to run in batch mode.\n * @returns {*} The result of the function.\n */\nconst batch = (fn) => {\n    batchDepth++;\n    const result = fn();\n    if (!--batchDepth && pendingEffects) {\n        flushEffects();\n    }\n    return result;\n};\n\n/**\n * Executes a function and immediately flushes all pending effects synchronously.\n *\n * This is useful when you need to ensure that all effects run immediately,\n * bypassing the auto-batching mechanism. This can be important for cases\n * where you need to read DOM measurements or perform operations that depend\n * on the effects having already run.\n *\n * @param {Function} fn - The function to execute.\n * @returns {*} The result of the function.\n */\nconst flushSync = (fn) => {\n    batchDepth++;\n    const result = fn();\n    batchDepth--;\n    if (pendingEffects) {\n        flushEffects();\n    }\n    return result;\n};\n\nexport { signal, effect, computed, batch, flushSync };\n", "import { renderTemplate } from \"./render.js\";\n\n// Pool de contenedores para reducir garbage collection\nconst containerPool = [];\nconst MAX_POOL_SIZE = 50;  // Incrementado de 10 a 50 para mejor eficiencia\nconst getContainer = () => containerPool.pop() || document.createElement(\"div\");\nconst releaseContainer = (c) => {\n    c.textContent = \"\";\n    c.innerHTML = \"\";  // Limpieza m\u00E1s completa\n    containerPool.length < MAX_POOL_SIZE && containerPool.push(c);\n};\n\n/**\n * Reconciles the children of a parent DOM node with an array of new templates.\n *\n * This function updates the DOM by matching existing keyed nodes with new templates,\n * applying necessary patches, and adding or removing nodes as needed. Existing nodes\n * are reused and updated if they match a template by key, otherwise new nodes are created.\n * Unused nodes are removed from the DOM.\n *\n * @param {Node} parent - The parent DOM node whose children will be reconciled.\n * @param {Array} newTemplates - An array of template objects, each containing a `_key`\n *     property for node matching, and other properties necessary for rendering.\n */\nfunction reconcileArray(parent, newTemplates) {\n    const oldNodesMap = new Map();\n    const children = parent.children;\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        child._key !== undefined && oldNodesMap.set(child._key, child);\n    }\n\n    const newNodes = [];\n    for (let i = 0; i < newTemplates.length; i++) {\n        const template = newTemplates[i];\n        const key = template._key;\n        const oldNode = oldNodesMap.get(key);\n\n        const tempContainer = getContainer();\n        renderTemplate(tempContainer, template);\n        const newNode = tempContainer.firstElementChild;\n\n        if (oldNode && newNode) {\n            patchNode(oldNode, newNode);\n            newNodes.push(oldNode);\n            oldNodesMap.delete(key);\n        } else if (newNode) {\n            newNode._key = key;\n            newNodes.push(newNode);\n        }\n\n        releaseContainer(tempContainer);\n    }\n\n    for (const node of oldNodesMap.values()) {\n        node._cleanup?.();\n        parent.removeChild(node);\n    }\n\n    for (let i = 0; i < newNodes.length; i++) {\n        const expectedNode = newNodes[i];\n        const currentNode = children[i];\n        currentNode !== expectedNode &&\n            parent.insertBefore(expectedNode, currentNode || null);\n    }\n}\n\n/**\n * Checks if two nodes are of the same type for reconciliation purposes.\n * @param {Node} a - First node\n * @param {Node} b - Second node\n * @returns {boolean} True if nodes can be patched\n * @private\n */\nfunction isSameNodeType(a, b) {\n    return a.nodeType === b.nodeType &&\n           (a.nodeType !== 1 || a.tagName === b.tagName);\n}\n\n/**\n * Optimized children patching with heuristics for common cases.\n * @param {Node} parent - Parent DOM node\n * @param {NodeList} oldChildren - Current children\n * @param {NodeList} newChildren - New children to reconcile\n * @private\n */\nfunction patchChildren(parent, oldChildren, newChildren) {\n    const oldLen = oldChildren.length;\n    const newLen = newChildren.length;\n\n    // Heuristic 1: Fast path for small lists (most common case)\n    if (oldLen < 20 && newLen < 20) {\n        const maxLen = Math.max(oldLen, newLen);\n        for (let i = 0; i < maxLen; i++) {\n            const oldChild = oldChildren[i];\n            const newChild = newChildren[i];\n\n            if (!oldChild) {\n                parent.appendChild(newChild.cloneNode(true));\n            } else if (!newChild) {\n                oldChild._cleanup?.();\n                parent.removeChild(oldChild);\n            } else {\n                patchNode(oldChild, newChild);\n            }\n        }\n        return;\n    }\n\n    // Heuristic 2: Same start - skip identical prefix\n    let startIdx = 0;\n    while (startIdx < oldLen && startIdx < newLen &&\n           isSameNodeType(oldChildren[startIdx], newChildren[startIdx])) {\n        patchNode(oldChildren[startIdx], newChildren[startIdx]);\n        startIdx++;\n    }\n\n    // Heuristic 3: Same end - skip identical suffix\n    let oldEndIdx = oldLen - 1;\n    let newEndIdx = newLen - 1;\n    while (oldEndIdx >= startIdx && newEndIdx >= startIdx &&\n           isSameNodeType(oldChildren[oldEndIdx], newChildren[newEndIdx])) {\n        patchNode(oldChildren[oldEndIdx], newChildren[newEndIdx]);\n        oldEndIdx--;\n        newEndIdx--;\n    }\n\n    // Heuristic 4: Only additions at the end\n    if (startIdx > oldEndIdx && startIdx <= newEndIdx) {\n        const ref = newChildren[newEndIdx + 1]?.nextSibling || null;\n        for (let i = startIdx; i <= newEndIdx; i++) {\n            parent.insertBefore(newChildren[i].cloneNode(true), ref);\n        }\n        return;\n    }\n\n    // Heuristic 5: Only removals from the end\n    if (startIdx > newEndIdx) {\n        for (let i = startIdx; i <= oldEndIdx; i++) {\n            oldChildren[i]._cleanup?.();\n            parent.removeChild(oldChildren[i]);\n        }\n        return;\n    }\n\n    // Remaining complex cases: use general patching\n    const maxLen = Math.max(oldEndIdx - startIdx + 1, newEndIdx - startIdx + 1);\n    for (let i = 0; i < maxLen; i++) {\n        const oldIdx = startIdx + i;\n        const newIdx = startIdx + i;\n        const oldChild = oldIdx <= oldEndIdx ? oldChildren[oldIdx] : null;\n        const newChild = newIdx <= newEndIdx ? newChildren[newIdx] : null;\n\n        if (!oldChild && newChild) {\n            parent.insertBefore(newChild.cloneNode(true), oldChildren[oldIdx] || null);\n        } else if (oldChild && !newChild) {\n            oldChild._cleanup?.();\n            parent.removeChild(oldChild);\n        } else if (oldChild && newChild) {\n            patchNode(oldChild, newChild);\n        }\n    }\n}\n\n/**\n * Patches an existing DOM node with a new node.\n *\n * This function compares two nodes and updates the old node to match the new node.\n * If both nodes are element nodes with the same tag name, it synchronizes their\n * attributes and children. If they are text nodes, it updates the text content.\n * If the nodes are of different types or have different tag names, the old node\n * is replaced with a clone of the new node.\n *\n * @param {Node} oldNode - The node to be updated.\n * @param {Node} newNode - The node with new properties to update the old node.\n */\nfunction patchNode(oldNode, newNode) {\n    const oldType = oldNode.nodeType;\n    const newType = newNode.nodeType;\n\n    if (oldType === 1 && newType === 1) {\n        // Element nodes\n        if (oldNode.tagName !== newNode.tagName) {\n            oldNode.replaceWith(newNode.cloneNode(true));\n            return;\n        }\n\n        // Update attributes\n        const oldAttrs = oldNode.attributes;\n        const newAttrs = newNode.attributes;\n        const toRemove = [];\n\n        for (let i = oldAttrs.length - 1; i >= 0; i--) {\n            const { name } = oldAttrs[i];\n            !newNode.hasAttribute(name) && toRemove.push(name);\n        }\n\n        for (let i = 0; i < newAttrs.length; i++) {\n            const { name, value } = newAttrs[i];\n            if (name === \"value\" || name === \"checked\") {\n                oldNode[name] !== value && (oldNode[name] = value);\n            } else {\n                oldNode.getAttribute(name) !== value &&\n                    oldNode.setAttribute(name, value);\n            }\n        }\n\n        for (let i = 0; i < toRemove.length; i++) {\n            oldNode.removeAttribute(toRemove[i]);\n        }\n\n        // Update children using optimized patching\n        patchChildren(oldNode, oldNode.childNodes, newNode.childNodes);\n    } else if (oldType === 3 && newType === 3) {\n        // Text nodes\n        oldNode.textContent !== newNode.textContent &&\n            (oldNode.textContent = newNode.textContent);\n    } else {\n        oldNode.replaceWith(newNode.cloneNode(true));\n    }\n}\n\nexport { reconcileArray };\n", "import { effect } from \"../hooks/reactivity.js\";\nimport { reconcileArray } from \"./reconcile.js\";\n\nconst MARKER = \"\\uFEFF\";\nconst cache = new WeakMap();\n\n// Template fragment cache for static/semi-static templates\nconst fragmentCache = new WeakMap();\nconst MAX_FRAGMENT_CACHE = 20;\n\n/**\n * Creates a template object with placeholders replaced by provided values.\n *\n * @param {TemplateStringsArray} strings - Template strings with placeholders.\n * @param {...any} allValues - Values to be inserted into the template.\n * @returns {object} Template object with template, values, _isTemplate, and _key properties.\n */\nconst html = (strings, ...allValues) => {\n    let cached = cache.get(strings);\n    if (!cached) {\n        const template = document.createElement(\"template\");\n        template.innerHTML = strings.join(MARKER);\n        const keyAttrIndex = strings.findIndex((s) =>\n            s.trim().endsWith(\"key=\")\n        );\n        cached = { template, keyAttrIndex };\n        cache.set(strings, cached);\n    }\n    const { template, keyAttrIndex } = cached;\n    let key,\n        otherValues = [...allValues];\n    if (keyAttrIndex !== -1) {\n        key = allValues[keyAttrIndex];\n        otherValues.splice(keyAttrIndex, 1);\n    }\n\n    // Detect if template has reactive values for caching optimization\n    const hasReactiveValues = otherValues.some(v => typeof v === 'function');\n    const isStatic = otherValues.length === 0;\n\n    return {\n        template,\n        values: otherValues,\n        _isTemplate: true,\n        _key: key,\n        _isStatic: isStatic,\n        _hasReactiveValues: hasReactiveValues\n    };\n};\n\n/**\n * Renders a value into a parent DOM node.\n *\n * This function will recursively traverse the value, applying the following rules:\n * - If the value is an array of template objects, reconcile the array with the parent.\n * - If the value is a template object, render the template into the parent.\n * - If the value is an array of non-template objects, render each item in the array\n *   into the parent.\n * - If the value is a DOM node, append it to the parent.\n * - If the value is a string or number, create a text node and append it to the parent.\n * - If the value is null, undefined, or false, do nothing.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered value.\n * @param {any} value - The value to be rendered.\n * @param {boolean} [shouldClear=true] - Whether to clear the parent before rendering.\n */\nconst renderValue = (parent, value, shouldClear = true) => {\n    if (Array.isArray(value)) {\n        if (value.length && value[0]?._key !== undefined) {\n            reconcileArray(parent, value);\n            return;\n        }\n        if (shouldClear && !(parent instanceof DocumentFragment)) {\n            parent.textContent = \"\";\n        }\n        for (let i = 0; i < value.length; i++) {\n            const tempContainer = document.createDocumentFragment();\n            renderValue(tempContainer, value[i], false);\n            parent.appendChild(tempContainer);\n        }\n        return;\n    }\n\n    if (shouldClear && !(parent instanceof DocumentFragment)) {\n        parent.textContent = \"\";\n    }\n\n    if (value == null || value === false) return;\n\n    if (value._isTemplate) {\n        renderTemplate(parent, value);\n    } else if (value instanceof Node) {\n        parent.appendChild(value);\n    } else {\n        parent.appendChild(document.createTextNode(String(value)));\n    }\n};\n\n/**\n * Renders a template object and its values into a parent DOM node.\n *\n * This function will recursively traverse the template, replacing placeholders\n * with provided values. It will also call any functions that were passed as values\n * and inject the result into the DOM.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered template.\n * @param {object} templateObject - An object with `template` and `values` properties.\n *     The `template` property should be a template element, and the `values` property\n *     should be an array of values to be inserted into the template.\n */\nconst renderTemplate = (parent, { template, values, _isStatic, _hasReactiveValues }) => {\n    // Fast path 1: Completely static templates (no values at all)\n    if (_isStatic) {\n        let fragment = fragmentCache.get(template);\n        if (!fragment) {\n            fragment = template.content.cloneNode(true);\n            // Cache if under limit\n            if (fragmentCache.size < MAX_FRAGMENT_CACHE) {\n                fragmentCache.set(template, template.content.cloneNode(true));\n            }\n        } else {\n            fragment = fragment.cloneNode(true);\n        }\n        parent.appendChild(fragment);\n        return;\n    }\n\n    // Fast path 2: Semi-static templates (no reactive values)\n    // For these, we can use the cached structure but still need to process non-reactive values\n    if (!_hasReactiveValues && fragmentCache.size < MAX_FRAGMENT_CACHE) {\n        let cached = fragmentCache.get(template);\n        if (cached) {\n            parent.appendChild(cached.cloneNode(true));\n            return;\n        }\n    }\n\n    // Standard path: Clone and process template\n    const content = template.content.cloneNode(true);\n    let valueIndex = 0;\n\n    const processNode = (node) => {\n        if (\n            node.nodeType === Node.TEXT_NODE &&\n            node.nodeValue.includes(MARKER)\n        ) {\n            const parts = node.nodeValue.split(MARKER);\n            const fragment = document.createDocumentFragment();\n            for (let i = 0; i < parts.length; i++) {\n                if (i > 0) {\n                    const value = values[valueIndex++];\n                    if (typeof value === \"function\") {\n                        const placeholder = document.createElement(\"span\");\n                        fragment.appendChild(placeholder);\n                        effect(() => renderValue(placeholder, value()));\n                    } else {\n                        renderValue(fragment, value, false);\n                    }\n                }\n                if (parts[i])\n                    fragment.appendChild(document.createTextNode(parts[i]));\n            }\n            node.parentNode.replaceChild(fragment, node);\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\n            const attrs = [];\n            for (let i = 0; i < node.attributes.length; i++) {\n                const attr = node.attributes[i];\n                if (attr.name !== \"key\" && attr.value === MARKER)\n                    attrs.push(attr);\n            }\n            for (let i = 0; i < attrs.length; i++) {\n                const attr = attrs[i];\n                const value = values[valueIndex++];\n                const name = attr.name;\n                node.removeAttribute(name);\n\n                if (name === \"ref\") {\n                    typeof value === \"function\"\n                        ? value(node)\n                        : value && (value.current = node);\n                } else if (name === \"style\" && value && typeof value === \"object\") {\n                    typeof value === \"function\"\n                        ? effect(() => Object.assign(node.style, value()))\n                        : Object.assign(node.style, value);\n                } else if (name[0] === \"o\" && name[1] === \"n\") {\n                    const eventName = name.slice(2).toLowerCase();\n                    if (typeof value === \"function\") {\n                        node._cleanup?.();\n                        node.addEventListener(eventName, value);\n                        node._cleanup = () =>\n                            node.removeEventListener(eventName, value);\n                    }\n                } else if (typeof value === \"function\") {\n                    if (node.tagName?.includes(\"-\")) {\n                        node._functionProps ||= {};\n                        node._functionProps[name] = value;\n                    } else {\n                        effect(() => {\n                            const val = value();\n                            name === \"value\" || name === \"checked\" || name === \"selected\"\n                                ? (node[name] = val)\n                                : val == null || val === false\n                                ? node.removeAttribute(name)\n                                : node.setAttribute(name, val === true ? \"\" : val);\n                        });\n                    }\n                } else {\n                    name === \"value\" || name === \"checked\" || name === \"selected\"\n                        ? (node[name] = value)\n                        : value == null || value === false\n                        ? void 0\n                        : node.setAttribute(name, value === true ? \"\" : value);\n                }\n            }\n            node.hasAttribute(\"key\") && node.removeAttribute(\"key\");\n            for (let i = 0; i < node.childNodes.length; i++)\n                processNode(node.childNodes[i]);\n        }\n    };\n\n    for (let i = 0; i < content.childNodes.length; i++) {\n        processNode(content.childNodes[i]);\n    }\n\n    // Cache semi-static templates (no reactive values) for future renders\n    if (!_hasReactiveValues && fragmentCache.size < MAX_FRAGMENT_CACHE) {\n        fragmentCache.set(template, content.cloneNode(true));\n    }\n\n    parent.appendChild(content);\n};\n\nexport { renderTemplate, html };\n", "let ctx = null;\nconst LIFECYCLE_HOOKS = [\n    \"beforeMount\",\n    \"mount\",\n    \"beforeUpdate\",\n    \"update\",\n    \"destroy\",\n];\n\n/**\n * Initializes the lifecycle system for a component.\n * @param {object} h - The host component to which the lifecycle is attached.\n * Sets up the lifecycle hooks for the component and defines a method to run\n * these hooks.\n */\nexport const createLifecycle = (h) => {\n    ctx = h;\n    h._lifecycles = Object.fromEntries(LIFECYCLE_HOOKS.map((k) => [k, []]));\n    h.runHook = (k) => {\n        const hooks = h._lifecycles?.[k];\n        if (!hooks?.length) return;\n\n        // Batch ejecutar hooks en un solo microtask\n        queueMicrotask(() => {\n            for (let i = 0; i < hooks.length; i++) {\n                hooks[i].call(h);\n            }\n        });\n    };\n};\n\n/**\n * Adds a lifecycle hook function to the current component's lifecycle system.\n *\n * @param {string} k - The name of the lifecycle hook.\n * @param {Function} fn - The function to add as a hook.\n * @throws {Error} If called outside of a component's setup phase.\n */\nconst addHook = (k, fn) => {\n    if (!ctx?._lifecycles)\n        throw new Error(`[Esor] Hook called outside ctx setup for \"${k}\"`);\n\n    ctx._lifecycles[k].push(fn);\n};\n\nconst exportedHooks = {};\nLIFECYCLE_HOOKS.forEach((h) => {\n    const fnName = h.startsWith(\"before\")\n        ? h\n        : `on${h[0].toUpperCase()}${h.slice(1)}`;\n    exportedHooks[fnName] = (fn) => addHook(h, fn);\n});\n\n/**\n * Registers an effect function that may return a cleanup function.\n * The cleanup function, if provided, will be registered to run during the \"destroy\" lifecycle phase.\n *\n * @param {Function} fn - The effect function to execute. It may optionally return a cleanup function.\n * @returns {Function} A no-op function.\n */\nexport const onEffect = (fn) => {\n    const cleanup = fn();\n    typeof cleanup === \"function\" && addHook(\"destroy\", cleanup);\n    return () => {};\n};\n\n/**\n * Retrieves the current lifecycle context (component host).\n * This function exposes the internal module-scoped `ctx` variable, which holds\n * the current component instance during its setup phase.\n * @returns {object|null} The current component context, or null if called outside of a component's setup phase.\n * @warning Use with caution. Accessing context outside of a component's synchronous\n * setup phase or in asynchronous contexts can lead to unexpected behavior or retrieving\n * a stale or incorrect context.\n */\nexport const getCurrentContext = () => {\n    !ctx &&\n        console.warn(\"getCurrentContext called outside of component lifecycle\");\n    return ctx;\n};\n\nexport const { beforeMount, onMount, beforeUpdate, onUpdate, onDestroy } =\n    exportedHooks;\n", "/**\n * Parses a given attribute value string into an appropriate JavaScript type.\n *\n * - If the value is `null` or `undefined`, returns an empty string.\n * - If the value is the string \"true\", returns the boolean `true`.\n * - If the value is the string \"false\", returns the boolean `false`.\n * - If the value matches the numeric regular expression, returns a `Number`.\n * - If the value is a string that looks like JSON (starts with '{' or '['),\n *   attempts to parse it as JSON and returns the result. If parsing fails,\n *   returns the original string.\n * - Otherwise, returns the original string value.\n *\n * @param {string} v - The attribute value to parse.\n * @returns {any} - The parsed value in an appropriate JavaScript type.\n */\nexport const parseAttributeValue = (v) => {\n    if (v == null) return \"\";\n    if (v === \"true\") return true;\n    if (v === \"false\") return false;\n\n    // Optimizaci\u00F3n: verificar primer caracter antes de regex\n    const first = v[0];\n    if (first === \"-\" || (first >= \"0\" && first <= \"9\")) {\n        const num = +v;\n        if (num === num) return num; // NaN check\n    }\n\n    if (first === \"{\" || first === \"[\") {\n        try {\n            return JSON.parse(v);\n        } catch {}\n    }\n    return v;\n};\n\n/**\n * Initializes properties from attributes of a host element.\n *\n * @param {HTMLElement} h - Element host\n */\nexport const initializeProps = (h) => {\n    h._functionProps && Object.assign(h.props, h._functionProps);\n    const attrs = h.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const { name: n, value: v } = attrs[i];\n        const first = n[0];\n        const second = n[1];\n\n        // Skip event handlers y refs (optimizaci\u00F3n de string checks)\n        if (\n            (first === \"o\" && second === \"n\") ||\n            (first === \"r\" && second === \"e\" && n[2] === \"f\")\n        )\n            continue;\n        if (v === \"function\" && h._functionProps?.[n]) continue;\n\n        h.props[n] = parseAttributeValue(v);\n    }\n};\n", "/**\n * Retrieves and caches all style elements and stylesheet links within the document's head.\n *\n * This function selects all <style> elements and <link> elements with a rel attribute\n * of \"stylesheet\" from the document's head section. It caches the results for future\n * use, ensuring that the query is only executed once and subsequent calls return the\n * cached results.\n *\n * @returns {Array} An array of style and link elements representing the stylesheets\n * in the document's head.\n */\nexport const s = () =>\n    (s.cache ||= [\n        ...document.querySelectorAll(\"head style, head link[rel=stylesheet]\"),\n    ]);\n", "import { renderTemplate } from \"./template/render.js\";\nimport { createLifecycle } from \"./lifecycle.js\";\nimport { initializeProps } from \"./props.js\";\nimport { s } from \"./utils/dom.js\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9]*-[a-z0-9-]*$/;\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, options = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: options.shadowMode || \"open\" });\n        props = Object.create(null);\n        _cleanup = [];\n\n        constructor() {\n            super();\n            this.#initializeComponent();\n            this.runHook(\"beforeMount\");\n        }\n\n        #initializeComponent() {\n            createLifecycle(this);\n            initializeProps(this);\n            options.globalStyles &&\n                s().forEach((s) => this.#shadow.appendChild(s.cloneNode(true)));\n            const template = setup?.call(this, this.props);\n            renderTemplate(this.#shadow, template);\n        }\n\n        connectedCallback() {\n            this.runHook(\"mount\");\n        }\n        disconnectedCallback() {\n            this._cleanup.forEach((c) => c());\n            this._cleanup = [];\n            this.runHook(\"destroy\");\n        }\n    };\n\n/**\n * Registers a custom element with the specified tag name and setup function.\n *\n * @param {string} tagName The tag name for the custom element. Must be a valid\n *     custom element name according to the custom elements specification.\n * @param {function} [setup] An optional function to initialize the component.\n *     It receives the component's properties and should return a template to be\n *     rendered into the component's shadow DOM.\n * @param {object} [options] Optional configuration for the component.\n *     Supports the `mode` option, which can be `\"open\"` or `\"closed\"`,\n *     determining the accessibility of the component's shadow DOM.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    typeof customElements !== \"undefined\" &&\n        REGEX_TAG_NAME.test(tagName) &&\n        !customElements.get(tagName) &&\n        customElements.define(tagName, BaseComponent(setup, options));\n};\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (...v) => (v.length === 0 ? current : (current = v[0]));\n}\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    target?.dispatchEvent(event);\n    return event;\n}\n"],
  "mappings": "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",
  "names": ["currentEffect", "batchDepth", "pendingEffects", "autoBatchScheduled", "flushEffects", "effects", "fn", "signal", "initialValue", "value", "subscribers", "args", "newValue", "effect", "execute", "computed", "result", "batch", "containerPool", "MAX_POOL_SIZE", "getContainer", "releaseContainer", "c", "reconcileArray", "parent", "newTemplates", "oldNodesMap", "children", "i", "child", "newNodes", "template", "key", "oldNode", "tempContainer", "renderTemplate", "newNode", "patchNode", "node", "expectedNode", "currentNode", "isSameNodeType", "a", "b", "patchChildren", "oldChildren", "newChildren", "oldLen", "newLen", "maxLen", "oldChild", "newChild", "startIdx", "oldEndIdx", "newEndIdx", "ref", "oldIdx", "newIdx", "oldType", "newType", "oldAttrs", "newAttrs", "toRemove", "name", "value", "MARKER", "cache", "fragmentCache", "MAX_FRAGMENT_CACHE", "html", "strings", "allValues", "cached", "template", "keyAttrIndex", "s", "key", "otherValues", "hasReactiveValues", "v", "isStatic", "renderValue", "parent", "value", "shouldClear", "reconcileArray", "i", "tempContainer", "renderTemplate", "values", "_isStatic", "_hasReactiveValues", "fragment", "content", "valueIndex", "processNode", "node", "parts", "placeholder", "effect", "attrs", "attr", "name", "eventName", "val", "ctx", "LIFECYCLE_HOOKS", "createLifecycle", "h", "k", "hooks", "i", "addHook", "fn", "exportedHooks", "fnName", "onEffect", "cleanup", "getCurrentContext", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "parseAttributeValue", "v", "first", "num", "initializeProps", "h", "attrs", "i", "n", "second", "s", "REGEX_TAG_NAME", "BaseComponent", "setup", "options", "_shadow", "_instances", "initializeComponent_fn", "_a", "__privateAdd", "__publicField", "__privateMethod", "c", "createLifecycle", "initializeProps", "s", "__privateGet", "template", "renderTemplate", "component", "tagName", "ref", "initialValue", "current", "v", "emit", "name", "detail", "target", "event"]
}
