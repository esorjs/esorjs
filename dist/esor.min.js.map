{
  "version": 3,
  "sources": ["../src/utils/error.js", "../src/lifecycle.js", "../src/hooks/reactivity.js", "../src/props.js", "../src/hooks/emit.js", "../src/events.js", "../src/utils/dom.js", "../src/component.js", "../src/utils/parser.js", "../src/template/reconcile.js", "../src/template/html.js", "../src/hooks/ref.js"],
  "sourcesContent": ["/**\n * Handles errors centrally with context\n * @param {string} context - Context of error (module or function)\n * @param {Error|string} error - Error or message\n * @param {string} [level=\u201Cerror\u201D] - Log level (error, warn, info)\n * @returns {Error} Error processed for possible additional handling\n */\nexport function handleError(context, error, level = \"error\") {\n    const method = level === \"warn\" ? console.warn : console.error;\n    const errorObj = error instanceof Error ? error : new Error(String(error));\n    method(`[Esor Error] ${context}:`, errorObj.message);\n\n    return errorObj; // Allows chaining\n}\n", "import { handleError } from \"./utils/error.js\";\n\nlet ctx = null;\n\n// List of available hooks\nconst LIFECYCLE_HOOKS = [\n  \"beforeMount\",\n  \"mount\",\n  \"beforeUpdate\",\n  \"update\",\n  \"destroy\",\n];\n\n/**\n * Create a life cycle system for the component.\n * @param {object} host - The host of the component.\n */\nexport const createLifecycle = (host) => {\n  ctx = host;\n\n  host._lifecycles = Object.fromEntries(\n    LIFECYCLE_HOOKS.map((hook) => [hook, []])\n  );\n\n  host.runHook = (key) => {\n    const hooks = host._lifecycles?.[key];\n    if (!hooks?.length) return;\n\n    for (let i = 0; i < hooks.length; i++)\n      queueMicrotask(() => hooks[i].call(host));\n  };\n};\n\n/**\n * Adds a hook to the lifecycle system.\n * @param {string} key - The lifecycle key.\n * @param {Function} fn - The function to add.\n */\nconst addHook = (key, fn) => {\n  if (!ctx || !ctx._lifecycles) {\n    handleError(\"lifecycle\", `Hook called outside ctx setup for \"${key}\"`);\n    return;\n  }\n  ctx._lifecycles[key].push(fn);\n};\n\n// Generate hook functions dynamically\nconst exportedHooks = {};\nLIFECYCLE_HOOKS.forEach((hook) => {\n  // Convert names like \u201CbeforeMount\u201D to \u201CbeforeMount\u201D and \u201Cmount\u201D to \u201ConMount\u201D.\n  const fnName = hook.startsWith(\"before\")\n    ? hook\n    : `on${hook.charAt(0).toUpperCase() + hook.slice(1)}`;\n  exportedHooks[fnName] = (fn) => addHook(hook, fn);\n});\n\nexport const { beforeMount, onMount, beforeUpdate, onUpdate, onDestroy } =\n  exportedHooks;\n\n// onEffect is a special case that handles cleaning\nexport const onEffect = (fn) => {\n  const cleanup = fn();\n  if (typeof cleanup === \"function\") addHook(\"destroy\", cleanup);\n  return () => {};\n};\n\n/**\n * Gets the current lifecycle context (component host).\n * @returns {object|null} The current component context, or null if called outside of a component lifecycle.\n * @warning This function exposes internal state and should be used carefully.\n */\nexport const getCurrentContext = () => {\n  if (!ctx)\n    console.warn(\"getCurrentContext called outside of component lifecycle\");\n  return ctx;\n};\n", "let current = null,\n  depth = 0,\n  queue = [];\n\n/**\n * Creates a reactive signal that notifies subscribers when its value changes.\n * @param {any} initialValue - Initial value.\n * @returns {Function} - Getter/setter function to access and modify the value.\n */\nconst signal = (v) => {\n  const subs = [];\n\n  return (newV) => {\n    if (newV === undefined) {\n      // Getter - track dependency\n      return (\n        current &&\n          !subs.includes(current) &&\n          (subs.push(current), current.deps?.add(subs)),\n        v\n      );\n    }\n\n    // Setter\n    const next = typeof newV === \"function\" ? newV(v) : newV;\n    if (v !== next) {\n      v = next;\n      if (depth > 0) {\n        for (let i = 0; i < subs.length; i++)\n          if (!queue.includes(subs[i])) queue.push(subs[i]);\n      } else for (let i = 0; i < subs.length; i++) subs[i]();\n    }\n    return v;\n  };\n};\n\n/**\n * Creates a reactive effect that runs automatically when its dependencies change.\n * The effect function `fn` is executed immediately and re-executed whenever any\n * of the reactive signals it depends on are updated.\n *\n * @param {Function} fn - The function to execute when the effect is triggered.\n * @returns {Function} - A cleanup function to unsubscribe the effect from its dependencies.\n */\nconst effect = (fn) => {\n  const deps = new Set();\n  const run = () => {\n    // Cleanup previous subscriptions\n    for (const subs of deps) {\n      const i = subs.indexOf(run);\n      if (i !== -1) subs.splice(i, 1);\n    }\n\n    deps.clear();\n\n    current = run;\n    current.deps = deps;\n    fn();\n    current = null;\n  };\n\n  run();\n\n  // Return cleanup function\n  return () => {\n    for (const subs of deps) {\n      const i = subs.indexOf(run);\n      if (i !== -1) subs.splice(i, 1);\n    }\n    deps.clear();\n  };\n};\n\n/**\n * Creates a computed reactive value that is derived from other signals.\n * The computed value is the result of calling the `fn` function whenever any of\n * the reactive signals it depends on are updated.\n *\n * @param {Function} fn - The function to execute when the computed value is accessed.\n * @returns {Function} - A getter function with a `.dispose` method to clean up the computed value.\n */\nconst computed = (fn) => {\n  const s = signal();\n  effect(() => s(fn()));\n  return s;\n};\n\n/**\n * Batches multiple signal updates into a single update cycle.\n * This defers the execution of effects until all batched updates are complete,\n * optimizing rendering performance.\n *\n * @param {Function} fn - The function containing updates to batch.\n * @returns {any} - The result of the function `fn`.\n */\nconst batch = (fn) => {\n  depth++;\n  try {\n    return fn();\n  } finally {\n    --depth;\n    if (depth === 0) {\n      const queued = queue.splice(0);\n      for (let i = 0; i < queued.length; i++) queued[i]();\n    }\n  }\n};\n\nexport { signal, effect, computed, batch };\n", "import { signal } from \"./hooks/reactivity.js\";\n\nconst NUM_REGEX = /^-?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?$/;\n\n/**\n * Parse an attribute value to an appropriate JS type.\n *\n * Converts an attribute value to an appropriate JS type. If the value is null or undefined,\n * Returns an empty string. If the value is \u201Ctrue\u201D or \u201Cfalse\u201D, returns the corresponding boolean value.\n * corresponding boolean value. If the value can be parsed as a number (using a regular expression), * returns the corresponding boolean * value.\n If the value can be parsed as a number (using a regular * expression), it returns the number. If the value can be parsed as a JSON object or array (using a regular * expression), returns the number.\n * (using a regular expression and JSON.parse), returns the object or array. Otherwise, it returns the original value.\n * otherwise, it returns the original value.\n *\n * @param {any} v - The value of the attribute to parse.\n * @returns {any} The parsed value.\n */\nexport function parseAttributeValue(v) {\n    if (v == null) return \"\";\n    if (v === \"true\") return true;\n    if (v === \"false\") return false;\n    if (NUM_REGEX.test(v)) return Number(v);\n    if (typeof v === \"string\" && (v[0] === \"{\" || v[0] === \"[\"))\n        try {\n            return JSON.parse(v);\n        } catch {}\n\n    return v;\n}\n\n/**\n * Initializes properties from attributes of a host element.\n *\n * Iterates over the attributes of the host element and sets the corresponding property in the host's `props` object to a reactive signal.\n * The value of the signal is obtained by parsing the attribute value with the `parseAttributeValue` function.\n *\n * @param {HTMLElement} host - The element whose attributes are to be used to initialize its properties.\n */\nexport function initializeProps(host) {\n    for (const attr of host.attributes) {\n        const { name, value } = attr;\n        if (name.startsWith(\"on\") || name.startsWith(\"ref\")) continue;\n        host.props[name] = signal(parseAttributeValue(value));\n    }\n}\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    target?.dispatchEvent(event);\n    return event;\n}\n", "import { emit } from \"./hooks/emit\";\n\n/**\n * Initializes the event broadcasting system in a component\n * @param {HTMLElement} host - Host element for events\n */\nexport function initDispatch(host) {\n    if (!host) return;\n    host.emit = (event, detail) => emit(event, detail, host);\n}\n", "/**\n * Creates a DocumentFragment from an array of nodes, with optional marking and parent appending.\n *\n * @param {Array<Node>} nodes - Nodes to include in the fragment.\n * @param {Object} [options=null] - Optional configuration object.\n * @param {boolean} [options.mark=false] - If true, marks each node as system-generated.\n * @param {Node} [options.parent=null] - Optional parent node to append the fragment to.\n * @returns {DocumentFragment} The created DocumentFragment containing the nodes.\n */\n\nexport function createFragment(nodes, { mark = false, parent = null } = {}) {\n    const frag = document.createDocumentFragment();\n    if (!nodes?.length) return frag;\n\n    for (const node of nodes) {\n        if (!node) continue;\n        if (mark) node._marker = true;\n\n        frag.appendChild(\n            Array.isArray(node) ? createFragment(node, { mark }) : node\n        );\n    }\n\n    if (parent && frag.childNodes.length) parent.appendChild(frag);\n    return frag;\n}\n\n/**\n * Joins the keys of an object whose values are truthy in a space-separated string.\n *\n * @param {Object} obj - Object key pairs object: value.\n * @returns {string} - Space-separated string of keys.\n */\nexport function joinTruthy(obj) {\n    return Object.keys(obj)\n        .reduce((str, key) => (obj[key] ? str + key + \" \" : str), \"\")\n        .trim();\n}\n", "import { createLifecycle } from \"./lifecycle.js\";\nimport { initializeProps } from \"./props.js\";\nimport { initDispatch } from \"./events.js\";\nimport { createFragment } from \"./utils/dom.js\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9]*-[a-z0-9-]*$/;\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, options = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: options.shadowMode || \"open\" });\n        #mounted = false;\n        props = Object.create(null);\n        _cleanup = [];\n\n        constructor() {\n            super();\n            this.#initializeComponent();\n            this.runHook(\"beforeMount\");\n        }\n\n        #initializeComponent() {\n            createLifecycle(this);\n            initDispatch(this);\n            initializeProps(this);\n\n            // Call setup function with props and render result\n            const result = setup?.call(this, this.props);\n            const content = typeof result === \"function\" ? result() : result;\n            createFragment(content || [content], { parent: this.#shadow });\n        }\n\n        #setMounted(isMounted) {\n            if (this.#mounted === isMounted) return false;\n            this.#mounted = isMounted;\n            return true;\n        }\n\n        connectedCallback() {\n            if (!this.#setMounted(true)) return;\n            this.runHook(\"mount\");\n        }\n\n        disconnectedCallback() {\n            this._cleanup.forEach((cleanup) => cleanup());\n            this._cleanup = [];\n            this.runHook(\"destroy\");\n            this.#setMounted(false);\n        }\n    };\n\n/**\n * Registers a custom element with the given tag name and setup function.\n *\n * @param {string} tagName The tag name of the custom element.\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    if (\n        typeof customElements !== \"undefined\" &&\n        REGEX_TAG_NAME.test(tagName) &&\n        !customElements.get(tagName)\n    )\n        customElements.define(tagName, BaseComponent(setup, options));\n};\n", "/**\n * Sanitizes text strings to prevent HTML injection\n * @param {any} value - Value to sanitize\n * @returns {string} Sanitized text\n */\nexport const sanitizeHtml = (value) =>\n    value == null\n        ? \"\"\n        : String(value).replace(\n              /[&<>'\"]/g,\n              (c) =>\n                  ({\n                      \"&\": \"&amp;\",\n                      \"<\": \"&lt;\",\n                      \">\": \"&gt;\",\n                      \"'\": \"&#39;\",\n                      '\"': \"&quot;\",\n                  }[c])\n          );\n", "import { createFragment } from \"../utils/dom.js\";\n\n/**\n * Reconciles DOM nodes by comparing new node groups with previous ones and updating the DOM accordingly.\n *\n * This function efficiently updates the DOM structure to reflect changes in data by removing, reusing, or\n * inserting nodes as needed. It uses a marker node to determine where updates should occur and maintains\n * the order and integrity of node groups.\n *\n * @param {Array<Node|Array<Node>>} newGroupsData - An array of new node groups, where each group can be a single node or an array of nodes.\n * @param {Node} markerNode - A marker node that acts as a reference point for DOM updates.\n *\n * If the new data is empty, all existing nodes are removed. Otherwise, nodes are updated based on a key\n * derived from the node's attributes or index. Nodes that are no longer present are removed, and new nodes\n * are inserted. The function also handles moving nodes to maintain the correct order.\n */\nexport function reconcile(newGroupsData, markerNode) {\n    if (!markerNode?.parentNode) return;\n    const parent = markerNode.parentNode;\n\n    const prevGroups = markerNode._marker || [];\n    if (!newGroupsData?.length) {\n        for (const g of prevGroups)\n            g.nodes.forEach((n) => n?.parentNode?.removeChild(n));\n        markerNode._marker = [];\n        return;\n    }\n\n    const prevMap = new Map(prevGroups.map((g) => [g.key, g]));\n    const newGroups = newGroupsData.map((nodes, i) => {\n        nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : [nodes];\n        const key =\n            nodes.find((n) => n?.getAttribute?.(\"key\"))?.getAttribute(\"key\") ||\n            `__index_${i}`;\n        return { key, nodes };\n    });\n    const newMap = new Map(newGroups.map((g) => [g.key, g]));\n\n    for (const g of prevGroups)\n        if (!newMap.has(g.key))\n            g.nodes.forEach((n) => n?.parentNode?.removeChild(n));\n\n    let lastNode = markerNode;\n    for (const newGroup of newGroups) {\n        const prevGroup = prevMap.get(newGroup.key);\n\n        if (prevGroup) {\n            patchNodes(prevGroup.nodes, newGroup.nodes, parent);\n            if (prevGroup.nodes[0] !== lastNode.nextSibling) {\n                parent.insertBefore(\n                    createFragment(prevGroup.nodes),\n                    lastNode.nextSibling\n                );\n            }\n            newGroup.nodes = prevGroup.nodes;\n        } else {\n            parent.insertBefore(\n                createFragment(newGroup.nodes, { mark: true }),\n                lastNode.nextSibling\n            );\n        }\n        lastNode = newGroup.nodes[newGroup.nodes.length - 1] || lastNode;\n    }\n    markerNode._marker = newGroups;\n}\n\n/**\n * Patches the DOM nodes by comparing a list of previous nodes with a list of next nodes,\n * updating the parent DOM element accordingly. This function handles node addition, removal,\n * replacement, and updates for both element and text nodes.\n *\n * - If a node exists in the next list but not in the previous, it gets appended to the parent.\n * - If a node exists in the previous list but not in the next, it gets removed from the parent.\n * - If both nodes exist, but differ in type or tag, the previous node is replaced with the next.\n * - If both nodes are text nodes, their values are compared and updated if necessary.\n * - For element nodes, attributes are patched and child nodes are recursively patched.\n *\n * @param {Array<Node>} prevNodes - The array of previous nodes.\n * @param {Array<Node>} nextNodes - The array of nodes to update to.\n * @param {Node} parent - The parent node to which updates are applied.\n */\nfunction patchNodes(prevNodes, nextNodes, parent) {\n    for (let i = 0; i < Math.max(prevNodes.length, nextNodes.length); i++) {\n        const p = prevNodes[i],\n            n = nextNodes[i];\n        if (!p && n) parent.appendChild(n);\n        else if (p && !n) {\n            p._cleanup?.();\n            parent.removeChild(p);\n        } else if (p && n) {\n            if (p.nodeType !== n.nodeType || p.tagName !== n.tagName) {\n                parent.replaceChild(n, p);\n            } else if (p.nodeType === 3) {\n                if (p.nodeValue !== n.nodeValue) p.nodeValue = n.nodeValue;\n            } else if (p.nodeType === 1) {\n                patchAttributes(p, n);\n                patchNodes([...p.childNodes], [...n.childNodes], p);\n            }\n        }\n    }\n}\n\n/**\n  Patches the attributes of a DOM element more efficiently.\n  @param {Element} p - The element to patch.\n  @param {Element} next - The element from which to copy the attributes.\n*/\n function patchAttributes(p, next) {\n    const curr = {}, seen = new Set();\n    for (const { name: n, value: v } of p.attributes) curr[n] = v;\n\n    for (const { name: n, value: v } of next.attributes) {\n        if (curr[n] !== v) p.setAttribute(n, v);\n        seen.add(n);\n    }\n\n    for (const n in curr) if (!seen.has(n)) p.removeAttribute(n);\n}\n", "import { sanitizeHtml } from \"../utils/parser.js\";\nimport { effect } from \"../hooks/reactivity.js\";\nimport { createFragment, joinTruthy } from \"../utils/dom.js\";\nimport { reconcile } from \"./reconcile.js\";\n\nconst templCache = new WeakMap();\nconst MARKER = \"\\ufeff\"; // Invisible marker for processing\n\n/**\n * Assigns attributes, events, or content to a node, as appropriate.\n *\n * @param {Node} node - The node to process.\n * @param {string|null} attr - The attribute name (or null for content).\n * @param {any} value - The value to assign.\n */\nconst render = (node, attr, value) => {\n    if (attr) {\n        node.removeAttribute(attr);\n        if (attr === \"ref\") {\n            typeof value === \"function\"\n                ? value(node)\n                : value && (value.current = node);\n        } else if (\n            attr[0] === \"o\" &&\n            attr[1] === \"n\" &&\n            typeof value === \"function\"\n        ) {\n            const eventName = attr.slice(2).toLowerCase();\n            node.addEventListener(eventName, value);\n            node._cleanup = () => node.removeEventListener(eventName, value);\n        } else if (attr === \"style\" && typeof value === \"object\") {\n            effect(() => Object.assign(node.style, value));\n        } else {\n            effect(() =>\n                setAttribute(\n                    node,\n                    attr,\n                    typeof value === \"function\" ? value() : value\n                )\n            );\n        }\n        // Render node content\n    } else setContent(node, value);\n};\n\n/**\n * Sets an attribute on a node.\n *\n * If the attribute is \"value\" or \"checked\", sets the property directly.\n * If the value is null, undefined, or false, removes the attribute.\n * Otherwise, sets the attribute with the given value.\n *\n * @param {Node} node - The node to update.\n * @param {string} attr - The attribute name.\n * @param {any} value - The value to assign.\n */\nexport function setAttribute(node, attr, value) {\n    if (attr === \"value\" || attr === \"checked\") node[attr] = value;\n    else if (value === false || value === null || value === undefined)\n        node.removeAttribute(attr);\n    else\n        node.setAttribute(\n            attr,\n            typeof value === \"object\" ? joinTruthy(value) : value\n        );\n}\n\n/**\n * Replaces all nodes following a marker node with new nodes.\n *\n * @param {Node} markerNode - The marker node.\n * @param {Array<Node>} newNodes - The new nodes to insert.\n */\nfunction replaceNodes(markerNode, newNodes) {\n    const parent = markerNode.parentNode;\n    let next = markerNode.nextSibling;\n\n    // Remove all nodes until the next marker\n    while (next && next._marker) {\n        next._cleanup?.();\n        parent.removeChild(next);\n        next = markerNode.nextSibling;\n    }\n\n    if (newNodes?.length) {\n        insertFragment(\n            createFragment(newNodes, { mark: true }),\n            parent,\n            markerNode.nextSibling\n        );\n    }\n}\n\n/**\n * Updates the content of a node.\n *\n * If the value is an array, the reconciliation algorithm is used.\n * Otherwise, a text node is created.\n *\n * @param {Node} node - The node to update.\n * @param {any} value - The new value.\n */\nfunction setContent(node, value) {\n    const updateContent = (val) => {\n        if (val === true || val === false) val = \"\";\n        if (Array.isArray(val)) reconcile(val, node);\n        else {\n            const textValue = val == null ? \"\" : String(val);\n            const textNode = document.createTextNode(sanitizeHtml(textValue));\n            replaceNodes(node, [textNode]);\n        }\n    };\n    typeof value === \"function\"\n        ? effect(() => updateContent(value()))\n        : updateContent(value);\n}\n\n/**\n * Inserts a fragment into the DOM.\n *\n * @param {DocumentFragment} fragment - The fragment to insert.\n * @param {Node} parent - The parent node.\n * @param {Node|null} refNode - Reference node for insertion.\n */\nfunction insertFragment(fragment, parent, refNode = null) {\n    if (!fragment || !parent) return;\n    refNode && refNode.parentNode === parent\n        ? parent.insertBefore(fragment, refNode)\n        : parent.appendChild(fragment);\n}\n\n/**\n * Processes an HTML template and replaces markers with provided values.\n *\n * @param {HTMLTemplateElement} template - The template to process.\n * @param {Array<any>} data - The values to replace in the template.\n */\nfunction processTemplate(template, data) {\n    const nodes = [];\n    const walker = document.createTreeWalker(template.content, 1 | 4);\n    while (walker.nextNode()) nodes.push(walker.currentNode);\n\n    let idx = 0;\n    for (let i = 0; i < nodes.length; i++) {\n        const n = nodes[i];\n        if (n.nodeType === 1 && n.attributes.length) {\n            for (const attr of Array.from(n.attributes))\n                if (attr.value === MARKER) render(n, attr.name, data[idx++]);\n        } else if (n.nodeType === 3 && n.nodeValue.includes(MARKER)) {\n            if (n.nodeValue === MARKER) {\n                const comm = document.createComment(\"\");\n                n.parentNode.replaceChild(comm, n);\n                render(comm, null, data[idx++]);\n            } else {\n                const tmp = createNodes(n.nodeValue.replaceAll(MARKER, \"<!>\"));\n                const children = Array.from(tmp.content.childNodes);\n                for (let j = 0; j < children.length; j++) {\n                    const child = children[j];\n                    if (child.nodeType === 8) render(child, null, data[idx++]);\n                }\n                n.parentNode.replaceChild(tmp.content, n);\n            }\n        }\n    }\n}\n\n/**\n * Parses an HTML string into a template element or an array of nodes.\n *\n * @param {string} html - The HTML string to parse.\n * @param {Object} [options={}] - Options for output type.\n * @param {\"template\"|\"nodes\"} [options.as=\"template\"] - Whether to return a template or nodes.\n * @returns {HTMLTemplateElement|Array<Node>} - The parsed template or array of nodes.\n */\nconst createNodes = (html, opts) => {\n    const t = document.createElement(\"template\");\n    t.innerHTML = html;\n    return opts?.as === \"nodes\" ? [...t.content.childNodes] : t;\n};\n\n/**\n * Main function that creates DOM nodes from a template literal and interpolation data.\n *\n * @param {Array<string>} tpl - Template strings.\n * @param {...any} data - The data to interpolate.\n * @returns {Array<Node>} The created nodes.\n */\nconst html = (tpl, ...data) => {\n    const cachedTpl = templCache.get(tpl) || (templCache.set(tpl, tpl), tpl);\n\n    if (!data.length) {\n        return cachedTpl.length === 1\n            ? createNodes(cachedTpl[0], { as: \"nodes\" })\n            : createNodes(cachedTpl.join(\"\"), { as: \"nodes\" });\n    }\n\n    const template = createNodes(cachedTpl.join(MARKER));\n    processTemplate(template, data);\n    return [...template.content.childNodes];\n};\n\nexport { html };\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (v) => (v !== undefined ? (current = v) : current);\n}\n"],
  "mappings": "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",
  "names": ["handleError", "context", "error", "level", "method", "errorObj", "__name", "ctx", "LIFECYCLE_HOOKS", "createLifecycle", "__name", "host", "hook", "key", "hooks", "i", "addHook", "fn", "handleError", "exportedHooks", "fnName", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "onEffect", "cleanup", "getCurrentContext", "current", "depth", "queue", "signal", "__name", "v", "subs", "newV", "next", "i", "effect", "fn", "deps", "run", "computed", "s", "batch", "queued", "NUM_REGEX", "parseAttributeValue", "v", "__name", "initializeProps", "host", "attr", "name", "value", "signal", "emit", "name", "detail", "target", "event", "__name", "initDispatch", "host", "event", "detail", "emit", "__name", "createFragment", "nodes", "mark", "parent", "frag", "node", "__name", "joinTruthy", "obj", "str", "key", "REGEX_TAG_NAME", "BaseComponent", "__name", "setup", "options", "_shadow", "_mounted", "_instances", "initializeComponent_fn", "setMounted_fn", "_a", "__privateAdd", "__publicField", "__privateMethod", "cleanup", "createLifecycle", "initDispatch", "initializeProps", "result", "content", "createFragment", "__privateGet", "isMounted", "__privateSet", "component", "tagName", "sanitizeHtml", "__name", "value", "c", "reconcile", "newGroupsData", "markerNode", "parent", "prevGroups", "g", "n", "prevMap", "newGroups", "nodes", "i", "newMap", "lastNode", "newGroup", "prevGroup", "patchNodes", "createFragment", "__name", "prevNodes", "nextNodes", "p", "patchAttributes", "next", "curr", "seen", "v", "templCache", "MARKER", "render", "__name", "node", "attr", "value", "eventName", "effect", "setAttribute", "setContent", "joinTruthy", "replaceNodes", "markerNode", "newNodes", "parent", "next", "insertFragment", "createFragment", "updateContent", "val", "reconcile", "textValue", "textNode", "sanitizeHtml", "fragment", "refNode", "processTemplate", "template", "data", "nodes", "walker", "idx", "i", "n", "comm", "tmp", "createNodes", "children", "j", "child", "html", "opts", "t", "tpl", "cachedTpl", "ref", "initialValue", "current", "v", "__name"]
}
