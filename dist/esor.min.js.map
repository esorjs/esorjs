{
  "version": 3,
  "sources": ["../src/hooks/reactivity.js", "../src/template/reconcile.js", "../src/template/render.js", "../src/lifecycle.js", "../src/props.js", "../src/utils/dom.js", "../src/component.js", "../src/hooks/ref.js", "../src/hooks/emit.js"],
  "sourcesContent": ["let currentEffect = null;\nlet batchDepth = 0;\nlet pendingEffects = null;\n\n/**\n * Creates a reactive signal that notifies its subscribers when its value changes.\n *\n * Signals are reactive values that can be used to track state changes in your application.\n * When the signal's value is changed, all subscribed functions will be called with the new value.\n * Subscribers can be added either by calling the signal with no arguments (which will add the\n * current effect to the subscribers) or by calling the signal with a new value.\n *\n * @param {*} initialValue - The initial value of the signal.\n * @returns {Function} A function that can be used to get or set the signal's value.\n */\nconst signal = (initialValue) => {\n    let value = initialValue;\n    const subscribers = new Set();\n\n    return (...args) => {\n        if (!args.length) {\n            currentEffect && subscribers.add(currentEffect);\n            return value;\n        }\n\n        const newValue = args[0];\n        if (value !== newValue) {\n            value = newValue;\n            if (batchDepth) {\n                pendingEffects ||= new Set();\n                for (const fn of subscribers) pendingEffects.add(fn);\n            } else {\n                for (const fn of subscribers) fn();\n            }\n        }\n\n        return value;\n    };\n};\n\n/**\n * Creates an effect that runs a function and remembers it for future calls.\n *\n * Effects are functions that run a computation and remember themselves for\n * future calls. When an effect is called, it sets itself as the current effect\n * and then calls the computation. After the computation is done, it sets the\n * current effect back to null.\n *\n * @param {Function} fn - The computation to run.\n * @returns {Function} The effect function.\n */\nconst effect = (fn) => {\n    const execute = () => {\n        currentEffect = execute;\n        fn();\n        currentEffect = null;\n    };\n    execute();\n    return execute;\n};\n\n/**\n * Creates a computed signal that automatically updates based on its dependencies.\n *\n * A computed signal is a derived value that updates whenever the signals it depends\n * on change. When the provided function is executed, it tracks the dependencies,\n * and any changes to those dependencies will cause the computed function to re-run,\n * updating the computed signal's value.\n *\n * @param {Function} fn - The function that returns the computed value, which may depend\n * on other reactive signals.\n * @returns {Function} A signal function that returns the current computed value.\n */\n\nconst computed = (fn) => {\n    const result = signal(undefined);\n    effect(() => result(fn()));\n    return result;\n};\n\n/**\n * Runs a function without scheduling subscriber updates until all batches are complete.\n *\n * Batching is useful when you need to update multiple reactive signals\n * without notifying their subscribers until all updates are complete.\n * This can be useful for performance optimization.\n *\n * @param {Function} fn - The function to run in batch mode.\n * @returns {*} The result of the function.\n */\nconst batch = (fn) => {\n    batchDepth++;\n    const result = fn();\n    if (!--batchDepth && pendingEffects) {\n        const effects = pendingEffects;\n        pendingEffects = null;\n        for (const fn of effects) fn();\n    }\n    return result;\n};\n\nexport { signal, effect, computed, batch };\n", "import { renderTemplate } from \"./render.js\";\n\n// Pool de contenedores para reducir garbage collection\nconst containerPool = [];\nconst getContainer = () => containerPool.pop() || document.createElement(\"div\");\nconst releaseContainer = (c) => {\n    c.textContent = \"\";\n    containerPool.length < 10 && containerPool.push(c);\n};\n\n/**\n * Reconciles the children of a parent DOM node with an array of new templates.\n *\n * This function updates the DOM by matching existing keyed nodes with new templates,\n * applying necessary patches, and adding or removing nodes as needed. Existing nodes\n * are reused and updated if they match a template by key, otherwise new nodes are created.\n * Unused nodes are removed from the DOM.\n *\n * @param {Node} parent - The parent DOM node whose children will be reconciled.\n * @param {Array} newTemplates - An array of template objects, each containing a `_key`\n *     property for node matching, and other properties necessary for rendering.\n */\nfunction reconcileArray(parent, newTemplates) {\n    const oldNodesMap = new Map();\n    const children = parent.children;\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        child._key !== undefined && oldNodesMap.set(child._key, child);\n    }\n\n    const newNodes = [];\n    for (let i = 0; i < newTemplates.length; i++) {\n        const template = newTemplates[i];\n        const key = template._key;\n        const oldNode = oldNodesMap.get(key);\n\n        const tempContainer = getContainer();\n        renderTemplate(tempContainer, template);\n        const newNode = tempContainer.firstElementChild;\n\n        if (oldNode && newNode) {\n            patchNode(oldNode, newNode);\n            newNodes.push(oldNode);\n            oldNodesMap.delete(key);\n        } else if (newNode) {\n            newNode._key = key;\n            newNodes.push(newNode);\n        }\n\n        releaseContainer(tempContainer);\n    }\n\n    for (const node of oldNodesMap.values()) {\n        node._cleanup?.();\n        parent.removeChild(node);\n    }\n\n    for (let i = 0; i < newNodes.length; i++) {\n        const expectedNode = newNodes[i];\n        const currentNode = children[i];\n        currentNode !== expectedNode &&\n            parent.insertBefore(expectedNode, currentNode || null);\n    }\n}\n\n/**\n * Patches an existing DOM node with a new node.\n *\n * This function compares two nodes and updates the old node to match the new node.\n * If both nodes are element nodes with the same tag name, it synchronizes their\n * attributes and children. If they are text nodes, it updates the text content.\n * If the nodes are of different types or have different tag names, the old node\n * is replaced with a clone of the new node.\n *\n * @param {Node} oldNode - The node to be updated.\n * @param {Node} newNode - The node with new properties to update the old node.\n */\nfunction patchNode(oldNode, newNode) {\n    const oldType = oldNode.nodeType;\n    const newType = newNode.nodeType;\n\n    if (oldType === 1 && newType === 1) {\n        // Element nodes\n        if (oldNode.tagName !== newNode.tagName) {\n            oldNode.replaceWith(newNode.cloneNode(true));\n            return;\n        }\n\n        // Update attributes\n        const oldAttrs = oldNode.attributes;\n        const newAttrs = newNode.attributes;\n        const toRemove = [];\n\n        for (let i = oldAttrs.length - 1; i >= 0; i--) {\n            const { name } = oldAttrs[i];\n            !newNode.hasAttribute(name) && toRemove.push(name);\n        }\n\n        for (let i = 0; i < newAttrs.length; i++) {\n            const { name, value } = newAttrs[i];\n            if (name === \"value\" || name === \"checked\") {\n                oldNode[name] !== value && (oldNode[name] = value);\n            } else {\n                oldNode.getAttribute(name) !== value &&\n                    oldNode.setAttribute(name, value);\n            }\n        }\n\n        for (let i = 0; i < toRemove.length; i++) {\n            oldNode.removeAttribute(toRemove[i]);\n        }\n\n        // Update children\n        const oldChildren = oldNode.childNodes;\n        const newChildren = newNode.childNodes;\n        const oldLen = oldChildren.length;\n        const newLen = newChildren.length;\n        const maxLen = Math.max(oldLen, newLen);\n\n        for (let i = 0; i < maxLen; i++) {\n            const oldChild = oldChildren[i];\n            const newChild = newChildren[i];\n\n            if (!oldChild) {\n                oldNode.appendChild(newChild.cloneNode(true));\n            } else if (!newChild) {\n                oldChild._cleanup?.();\n                oldNode.removeChild(oldChild);\n            } else {\n                patchNode(oldChild, newChild);\n            }\n        }\n    } else if (oldType === 3 && newType === 3) {\n        // Text nodes\n        oldNode.textContent !== newNode.textContent &&\n            (oldNode.textContent = newNode.textContent);\n    } else {\n        oldNode.replaceWith(newNode.cloneNode(true));\n    }\n}\n\nexport { reconcileArray };\n", "import { effect } from \"../hooks/reactivity.js\";\nimport { reconcileArray } from \"./reconcile.js\";\n\nconst MARKER = \"\\uFEFF\";\nconst cache = new WeakMap();\n\n/**\n * Creates a template object with placeholders replaced by provided values.\n *\n * @param {TemplateStringsArray} strings - Template strings with placeholders.\n * @param {...any} allValues - Values to be inserted into the template.\n * @returns {object} Template object with template, values, _isTemplate, and _key properties.\n */\nconst html = (strings, ...allValues) => {\n    let cached = cache.get(strings);\n    if (!cached) {\n        const template = document.createElement(\"template\");\n        template.innerHTML = strings.join(MARKER);\n        const keyAttrIndex = strings.findIndex((s) =>\n            s.trim().endsWith(\"key=\")\n        );\n        cached = { template, keyAttrIndex };\n        cache.set(strings, cached);\n    }\n    const { template, keyAttrIndex } = cached;\n    let key,\n        otherValues = [...allValues];\n    if (keyAttrIndex !== -1) {\n        key = allValues[keyAttrIndex];\n        otherValues.splice(keyAttrIndex, 1);\n    }\n    return { template, values: otherValues, _isTemplate: true, _key: key };\n};\n\n/**\n * Renders a value into a parent DOM node.\n *\n * This function will recursively traverse the value, applying the following rules:\n * - If the value is an array of template objects, reconcile the array with the parent.\n * - If the value is a template object, render the template into the parent.\n * - If the value is an array of non-template objects, render each item in the array\n *   into the parent.\n * - If the value is a DOM node, append it to the parent.\n * - If the value is a string or number, create a text node and append it to the parent.\n * - If the value is null, undefined, or false, do nothing.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered value.\n * @param {any} value - The value to be rendered.\n * @param {boolean} [shouldClear=true] - Whether to clear the parent before rendering.\n */\nconst renderValue = (parent, value, shouldClear = true) => {\n    if (Array.isArray(value)) {\n        if (value.length && value[0]?._key !== undefined) {\n            reconcileArray(parent, value);\n            return;\n        }\n        if (shouldClear && !(parent instanceof DocumentFragment)) {\n            parent.textContent = \"\";\n        }\n        for (let i = 0; i < value.length; i++) {\n            const tempContainer = document.createDocumentFragment();\n            renderValue(tempContainer, value[i], false);\n            parent.appendChild(tempContainer);\n        }\n        return;\n    }\n\n    if (shouldClear && !(parent instanceof DocumentFragment)) {\n        parent.textContent = \"\";\n    }\n\n    if (value == null || value === false) return;\n\n    if (value._isTemplate) {\n        renderTemplate(parent, value);\n    } else if (value instanceof Node) {\n        parent.appendChild(value);\n    } else {\n        parent.appendChild(document.createTextNode(String(value)));\n    }\n};\n\n/**\n * Renders a template object and its values into a parent DOM node.\n *\n * This function will recursively traverse the template, replacing placeholders\n * with provided values. It will also call any functions that were passed as values\n * and inject the result into the DOM.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered template.\n * @param {object} templateObject - An object with `template` and `values` properties.\n *     The `template` property should be a template element, and the `values` property\n *     should be an array of values to be inserted into the template.\n */\nconst renderTemplate = (parent, { template, values }) => {\n    const content = template.content.cloneNode(true);\n    let valueIndex = 0;\n\n    const processNode = (node) => {\n        if (\n            node.nodeType === Node.TEXT_NODE &&\n            node.nodeValue.includes(MARKER)\n        ) {\n            const parts = node.nodeValue.split(MARKER);\n            const fragment = document.createDocumentFragment();\n            for (let i = 0; i < parts.length; i++) {\n                if (i > 0) {\n                    const value = values[valueIndex++];\n                    if (typeof value === \"function\") {\n                        const placeholder = document.createElement(\"span\");\n                        fragment.appendChild(placeholder);\n                        effect(() => renderValue(placeholder, value()));\n                    } else {\n                        renderValue(fragment, value, false);\n                    }\n                }\n                if (parts[i])\n                    fragment.appendChild(document.createTextNode(parts[i]));\n            }\n            node.parentNode.replaceChild(fragment, node);\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\n            const attrs = [];\n            for (let i = 0; i < node.attributes.length; i++) {\n                const attr = node.attributes[i];\n                if (attr.name !== \"key\" && attr.value === MARKER)\n                    attrs.push(attr);\n            }\n            for (let i = 0; i < attrs.length; i++) {\n                const attr = attrs[i];\n                const value = values[valueIndex++];\n                const name = attr.name;\n                node.removeAttribute(name);\n\n                if (name === \"ref\") {\n                    typeof value === \"function\"\n                        ? value(node)\n                        : value && (value.current = node);\n                } else if (name === \"style\" && value && typeof value === \"object\") {\n                    typeof value === \"function\"\n                        ? effect(() => Object.assign(node.style, value()))\n                        : Object.assign(node.style, value);\n                } else if (name[0] === \"o\" && name[1] === \"n\") {\n                    const eventName = name.slice(2).toLowerCase();\n                    if (typeof value === \"function\") {\n                        node._cleanup?.();\n                        node.addEventListener(eventName, value);\n                        node._cleanup = () =>\n                            node.removeEventListener(eventName, value);\n                    }\n                } else if (typeof value === \"function\") {\n                    if (node.tagName?.includes(\"-\")) {\n                        node._functionProps ||= {};\n                        node._functionProps[name] = value;\n                    } else {\n                        effect(() => {\n                            const val = value();\n                            name === \"value\" || name === \"checked\" || name === \"selected\"\n                                ? (node[name] = val)\n                                : val == null || val === false\n                                ? node.removeAttribute(name)\n                                : node.setAttribute(name, val === true ? \"\" : val);\n                        });\n                    }\n                } else {\n                    name === \"value\" || name === \"checked\" || name === \"selected\"\n                        ? (node[name] = value)\n                        : value == null || value === false\n                        ? void 0\n                        : node.setAttribute(name, value === true ? \"\" : value);\n                }\n            }\n            node.hasAttribute(\"key\") && node.removeAttribute(\"key\");\n            for (let i = 0; i < node.childNodes.length; i++)\n                processNode(node.childNodes[i]);\n        }\n    };\n\n    for (let i = 0; i < content.childNodes.length; i++) {\n        processNode(content.childNodes[i]);\n    }\n\n    parent.appendChild(content);\n};\n\nexport { renderTemplate, html };\n", "let ctx = null;\nconst LIFECYCLE_HOOKS = [\n    \"beforeMount\",\n    \"mount\",\n    \"beforeUpdate\",\n    \"update\",\n    \"destroy\",\n];\n\n/**\n * Initializes the lifecycle system for a component.\n * @param {object} h - The host component to which the lifecycle is attached.\n * Sets up the lifecycle hooks for the component and defines a method to run\n * these hooks.\n */\nexport const createLifecycle = (h) => {\n    ctx = h;\n    h._lifecycles = Object.fromEntries(LIFECYCLE_HOOKS.map((k) => [k, []]));\n    h.runHook = (k) => {\n        const hooks = h._lifecycles?.[k];\n        if (!hooks?.length) return;\n\n        // Batch ejecutar hooks en un solo microtask\n        queueMicrotask(() => {\n            for (let i = 0; i < hooks.length; i++) {\n                hooks[i].call(h);\n            }\n        });\n    };\n};\n\n/**\n * Adds a lifecycle hook function to the current component's lifecycle system.\n *\n * @param {string} k - The name of the lifecycle hook.\n * @param {Function} fn - The function to add as a hook.\n * @throws {Error} If called outside of a component's setup phase.\n */\nconst addHook = (k, fn) => {\n    if (!ctx?._lifecycles)\n        throw new Error(`[Esor] Hook called outside ctx setup for \"${k}\"`);\n\n    ctx._lifecycles[k].push(fn);\n};\n\nconst exportedHooks = {};\nLIFECYCLE_HOOKS.forEach((h) => {\n    const fnName = h.startsWith(\"before\")\n        ? h\n        : `on${h[0].toUpperCase()}${h.slice(1)}`;\n    exportedHooks[fnName] = (fn) => addHook(h, fn);\n});\n\n/**\n * Registers an effect function that may return a cleanup function.\n * The cleanup function, if provided, will be registered to run during the \"destroy\" lifecycle phase.\n *\n * @param {Function} fn - The effect function to execute. It may optionally return a cleanup function.\n * @returns {Function} A no-op function.\n */\nexport const onEffect = (fn) => {\n    const cleanup = fn();\n    typeof cleanup === \"function\" && addHook(\"destroy\", cleanup);\n    return () => {};\n};\n\n/**\n * Retrieves the current lifecycle context (component host).\n * This function exposes the internal module-scoped `ctx` variable, which holds\n * the current component instance during its setup phase.\n * @returns {object|null} The current component context, or null if called outside of a component's setup phase.\n * @warning Use with caution. Accessing context outside of a component's synchronous\n * setup phase or in asynchronous contexts can lead to unexpected behavior or retrieving\n * a stale or incorrect context.\n */\nexport const getCurrentContext = () => {\n    !ctx &&\n        console.warn(\"getCurrentContext called outside of component lifecycle\");\n    return ctx;\n};\n\nexport const { beforeMount, onMount, beforeUpdate, onUpdate, onDestroy } =\n    exportedHooks;\n", "/**\n * Parses a given attribute value string into an appropriate JavaScript type.\n *\n * - If the value is `null` or `undefined`, returns an empty string.\n * - If the value is the string \"true\", returns the boolean `true`.\n * - If the value is the string \"false\", returns the boolean `false`.\n * - If the value matches the numeric regular expression, returns a `Number`.\n * - If the value is a string that looks like JSON (starts with '{' or '['),\n *   attempts to parse it as JSON and returns the result. If parsing fails,\n *   returns the original string.\n * - Otherwise, returns the original string value.\n *\n * @param {string} v - The attribute value to parse.\n * @returns {any} - The parsed value in an appropriate JavaScript type.\n */\nexport const parseAttributeValue = (v) => {\n    if (v == null) return \"\";\n    if (v === \"true\") return true;\n    if (v === \"false\") return false;\n\n    // Optimizaci\u00F3n: verificar primer caracter antes de regex\n    const first = v[0];\n    if (first === \"-\" || (first >= \"0\" && first <= \"9\")) {\n        const num = +v;\n        if (num === num) return num; // NaN check\n    }\n\n    if (first === \"{\" || first === \"[\") {\n        try {\n            return JSON.parse(v);\n        } catch {}\n    }\n    return v;\n};\n\n/**\n * Initializes properties from attributes of a host element.\n *\n * @param {HTMLElement} h - Element host\n */\nexport const initializeProps = (h) => {\n    h._functionProps && Object.assign(h.props, h._functionProps);\n    const attrs = h.attributes;\n    for (let i = 0; i < attrs.length; i++) {\n        const { name: n, value: v } = attrs[i];\n        const first = n[0];\n        const second = n[1];\n\n        // Skip event handlers y refs (optimizaci\u00F3n de string checks)\n        if (\n            (first === \"o\" && second === \"n\") ||\n            (first === \"r\" && second === \"e\" && n[2] === \"f\")\n        )\n            continue;\n        if (v === \"function\" && h._functionProps?.[n]) continue;\n\n        h.props[n] = parseAttributeValue(v);\n    }\n};\n", "/**\n * Retrieves and caches all style elements and stylesheet links within the document's head.\n *\n * This function selects all <style> elements and <link> elements with a rel attribute\n * of \"stylesheet\" from the document's head section. It caches the results for future\n * use, ensuring that the query is only executed once and subsequent calls return the\n * cached results.\n *\n * @returns {Array} An array of style and link elements representing the stylesheets\n * in the document's head.\n */\nexport const s = () =>\n    (s.cache ||= [\n        ...document.querySelectorAll(\"head style, head link[rel=stylesheet]\"),\n    ]);\n", "import { renderTemplate } from \"./template/render.js\";\nimport { createLifecycle } from \"./lifecycle.js\";\nimport { initializeProps } from \"./props.js\";\nimport { s } from \"./utils/dom.js\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9]*-[a-z0-9-]*$/;\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, options = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: options.shadowMode || \"open\" });\n        props = Object.create(null);\n        _cleanup = [];\n\n        constructor() {\n            super();\n            this.#initializeComponent();\n            this.runHook(\"beforeMount\");\n        }\n\n        #initializeComponent() {\n            createLifecycle(this);\n            initializeProps(this);\n            options.globalStyles &&\n                s().forEach((s) => this.#shadow.appendChild(s.cloneNode(true)));\n            const template = setup?.call(this, this.props);\n            renderTemplate(this.#shadow, template);\n        }\n\n        connectedCallback() {\n            this.runHook(\"mount\");\n        }\n        disconnectedCallback() {\n            this._cleanup.forEach((c) => c());\n            this._cleanup = [];\n            this.runHook(\"destroy\");\n        }\n    };\n\n/**\n * Registers a custom element with the specified tag name and setup function.\n *\n * @param {string} tagName The tag name for the custom element. Must be a valid\n *     custom element name according to the custom elements specification.\n * @param {function} [setup] An optional function to initialize the component.\n *     It receives the component's properties and should return a template to be\n *     rendered into the component's shadow DOM.\n * @param {object} [options] Optional configuration for the component.\n *     Supports the `mode` option, which can be `\"open\"` or `\"closed\"`,\n *     determining the accessibility of the component's shadow DOM.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    typeof customElements !== \"undefined\" &&\n        REGEX_TAG_NAME.test(tagName) &&\n        !customElements.get(tagName) &&\n        customElements.define(tagName, BaseComponent(setup, options));\n};\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (...v) => (v.length === 0 ? current : (current = v[0]));\n}\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    target?.dispatchEvent(event);\n    return event;\n}\n"],
  "mappings": "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",
  "names": ["currentEffect", "batchDepth", "pendingEffects", "signal", "__name", "initialValue", "value", "subscribers", "args", "newValue", "fn", "effect", "execute", "computed", "result", "batch", "effects", "containerPool", "getContainer", "__name", "releaseContainer", "c", "reconcileArray", "parent", "newTemplates", "oldNodesMap", "children", "i", "child", "newNodes", "template", "key", "oldNode", "tempContainer", "renderTemplate", "newNode", "patchNode", "node", "expectedNode", "currentNode", "oldType", "newType", "oldAttrs", "newAttrs", "toRemove", "name", "value", "oldChildren", "newChildren", "oldLen", "newLen", "maxLen", "oldChild", "newChild", "MARKER", "cache", "html", "__name", "strings", "allValues", "cached", "template", "keyAttrIndex", "s", "key", "otherValues", "renderValue", "parent", "value", "shouldClear", "reconcileArray", "i", "tempContainer", "renderTemplate", "values", "content", "valueIndex", "processNode", "node", "parts", "fragment", "placeholder", "effect", "attrs", "attr", "name", "eventName", "val", "ctx", "LIFECYCLE_HOOKS", "createLifecycle", "__name", "h", "k", "hooks", "i", "addHook", "fn", "exportedHooks", "fnName", "onEffect", "cleanup", "getCurrentContext", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "parseAttributeValue", "__name", "v", "first", "num", "initializeProps", "h", "attrs", "i", "n", "second", "s", "__name", "REGEX_TAG_NAME", "BaseComponent", "__name", "setup", "options", "_shadow", "_instances", "initializeComponent_fn", "_a", "__privateAdd", "__publicField", "__privateMethod", "c", "createLifecycle", "initializeProps", "s", "__privateGet", "template", "renderTemplate", "component", "tagName", "ref", "initialValue", "current", "v", "__name", "emit", "name", "detail", "target", "event", "__name"]
}
