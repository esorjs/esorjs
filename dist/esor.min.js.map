{
  "version": 3,
  "sources": ["../src/hooks/reactivity.js", "../src/template/reconcile.js", "../src/template/render.js", "../src/lifecycle.js", "../src/props.js", "../src/utils/dom.js", "../src/component.js", "../src/hooks/ref.js", "../src/hooks/emit.js"],
  "sourcesContent": ["let currentEffect = null;\nlet batchDepth = 0;\n\n/**\n * Creates a reactive signal that notifies its subscribers when its value changes.\n *\n * Signals are reactive values that can be used to track state changes in your application.\n * When the signal's value is changed, all subscribed functions will be called with the new value.\n * Subscribers can be added either by calling the signal with no arguments (which will add the\n * current effect to the subscribers) or by calling the signal with a new value.\n *\n * @param {*} initialValue - The initial value of the signal.\n * @returns {Function} A function that can be used to get or set the signal's value.\n */\nconst signal = (initialValue) => {\n    let value = initialValue;\n    const subscribers = new Set();\n\n    return (...args) => {\n        if (args.length === 0) {\n            currentEffect && subscribers.add(currentEffect);\n            return value;\n        }\n\n        const newValue = args[0];\n        if (value !== newValue) {\n            value = newValue;\n            if (batchDepth === 0) for (const fn of subscribers) fn();\n        }\n\n        return value;\n    };\n};\n\n/**\n * Creates an effect that runs a function and remembers it for future calls.\n *\n * Effects are functions that run a computation and remember themselves for\n * future calls. When an effect is called, it sets itself as the current effect\n * and then calls the computation. After the computation is done, it sets the\n * current effect back to null.\n *\n * @param {Function} fn - The computation to run.\n * @returns {Function} The effect function.\n */\nconst effect = (fn) => {\n    const execute = () => {\n        currentEffect = execute;\n        fn();\n        currentEffect = null;\n    };\n    execute();\n    return execute;\n};\n\n/**\n * Creates a computed signal that automatically updates based on its dependencies.\n *\n * A computed signal is a derived value that updates whenever the signals it depends\n * on change. When the provided function is executed, it tracks the dependencies,\n * and any changes to those dependencies will cause the computed function to re-run,\n * updating the computed signal's value.\n *\n * @param {Function} fn - The function that returns the computed value, which may depend\n * on other reactive signals.\n * @returns {Function} A signal function that returns the current computed value.\n */\n\nconst computed = (fn) => {\n    const result = signal(undefined);\n    effect(() => result(fn()));\n    return result;\n};\n\n/**\n * Runs a function without scheduling subscriber updates until all batches are complete.\n *\n * Batching is useful when you need to update multiple reactive signals\n * without notifying their subscribers until all updates are complete.\n * This can be useful for performance optimization.\n *\n * @param {Function} fn - The function to run in batch mode.\n * @returns {*} The result of the function.\n */\nconst batch = (fn) => {\n    batchDepth++;\n    const result = fn();\n    --batchDepth;\n    return result;\n};\n\nexport { signal, effect, computed, batch };\n", "import { renderTemplate } from \"./render.js\";\n\n/**\n * Reconciles the children of a parent DOM node with an array of new templates.\n *\n * This function updates the DOM by matching existing keyed nodes with new templates,\n * applying necessary patches, and adding or removing nodes as needed. Existing nodes\n * are reused and updated if they match a template by key, otherwise new nodes are created.\n * Unused nodes are removed from the DOM.\n *\n * @param {Node} parent - The parent DOM node whose children will be reconciled.\n * @param {Array} newTemplates - An array of template objects, each containing a `_key`\n *     property for node matching, and other properties necessary for rendering.\n */\nfunction reconcileArray(parent, newTemplates) {\n    const oldNodesMap = new Map();\n    for (const child of parent.children) {\n        if (child._key !== undefined) oldNodesMap.set(child._key, child);\n    }\n\n    const newNodes = [];\n    for (const template of newTemplates) {\n        const key = template._key;\n        let oldNode = oldNodesMap.get(key);\n\n        const tempContainer = document.createElement(\"div\");\n        renderTemplate(tempContainer, template);\n        const newNode = tempContainer.firstElementChild;\n\n        if (oldNode && newNode) {\n            patchNode(oldNode, newNode);\n            newNodes.push(oldNode);\n            oldNodesMap.delete(key);\n        } else if (newNode) {\n            newNode._key = key;\n            newNodes.push(newNode);\n        }\n    }\n\n    for (const node of oldNodesMap.values()) {\n        node._cleanup?.();\n        parent.removeChild(node);\n    }\n\n    for (let i = 0; i < newNodes.length; i++) {\n        const expectedNode = newNodes[i];\n        const currentNode = parent.children[i];\n        if (currentNode !== expectedNode)\n            parent.insertBefore(expectedNode, currentNode || null);\n    }\n}\n\n/**\n * Patches an existing DOM node with a new node.\n *\n * This function compares two nodes and updates the old node to match the new node.\n * If both nodes are element nodes with the same tag name, it synchronizes their\n * attributes and children. If they are text nodes, it updates the text content.\n * If the nodes are of different types or have different tag names, the old node\n * is replaced with a clone of the new node.\n *\n * @param {Node} oldNode - The node to be updated.\n * @param {Node} newNode - The node with new properties to update the old node.\n */\nfunction patchNode(oldNode, newNode) {\n    if (\n        oldNode.nodeType === Node.ELEMENT_NODE &&\n        newNode.nodeType === Node.ELEMENT_NODE\n    ) {\n        if (oldNode.tagName !== newNode.tagName) {\n            oldNode.replaceWith(newNode.cloneNode(true));\n            return;\n        }\n\n        // Update attributes\n        const oldAttrs = new Map();\n        for (const { name, value } of oldNode.attributes)\n            oldAttrs.set(name, value);\n\n        for (const { name, value } of newNode.attributes) {\n            if (name === \"value\" || name === \"checked\") {\n                if (oldNode[name] !== value) oldNode[name] = value;\n            } else if (oldNode.getAttribute(name) !== value) {\n                oldNode.setAttribute(name, value);\n            }\n            oldAttrs.delete(name);\n        }\n\n        for (const name of oldAttrs.keys()) oldNode.removeAttribute(name);\n\n        // Update children\n        const oldChildren = Array.from(oldNode.childNodes);\n        const newChildren = Array.from(newNode.childNodes);\n        const maxLen = Math.max(oldChildren.length, newChildren.length);\n\n        for (let i = 0; i < maxLen; i++) {\n            const oldChild = oldChildren[i];\n            const newChild = newChildren[i];\n\n            if (!oldChild) oldNode.appendChild(newChild.cloneNode(true));\n            else if (!newChild) {\n                oldChild._cleanup?.();\n                oldNode.removeChild(oldChild);\n            } else patchNode(oldChild, newChild);\n        }\n    } else if (\n        oldNode.nodeType === Node.TEXT_NODE &&\n        newNode.nodeType === Node.TEXT_NODE\n    ) {\n        if (oldNode.textContent !== newNode.textContent)\n            oldNode.textContent = newNode.textContent;\n    } else oldNode.replaceWith(newNode.cloneNode(true));\n}\n\nexport { reconcileArray };\n", "import { effect } from \"../hooks/reactivity.js\";\nimport { reconcileArray } from \"./reconcile.js\";\n\nconst MARKER = \"\\uFEFF\";\nconst cache = new WeakMap();\n\n/**\n * Creates a template object with placeholders replaced by provided values.\n *\n * @param {TemplateStringsArray} strings - Template strings with placeholders.\n * @param {...any} allValues - Values to be inserted into the template.\n * @returns {object} Template object with template, values, _isTemplate, and _key properties.\n */\nconst html = (strings, ...allValues) => {\n    let cached = cache.get(strings);\n    if (!cached) {\n        const template = document.createElement(\"template\");\n        template.innerHTML = strings.join(MARKER);\n        const keyAttrIndex = strings.findIndex((s) =>\n            s.trim().endsWith(\"key=\")\n        );\n        cached = { template, keyAttrIndex };\n        cache.set(strings, cached);\n    }\n    const { template, keyAttrIndex } = cached;\n    let key,\n        otherValues = [...allValues];\n    if (keyAttrIndex !== -1) {\n        key = allValues[keyAttrIndex];\n        otherValues.splice(keyAttrIndex, 1);\n    }\n    return { template, values: otherValues, _isTemplate: true, _key: key };\n};\n\n/**\n * Renders a value into a parent DOM node.\n *\n * This function will recursively traverse the value, applying the following rules:\n * - If the value is an array of template objects, reconcile the array with the parent.\n * - If the value is a template object, render the template into the parent.\n * - If the value is an array of non-template objects, render each item in the array\n *   into the parent.\n * - If the value is a DOM node, append it to the parent.\n * - If the value is a string or number, create a text node and append it to the parent.\n * - If the value is null, undefined, or false, do nothing.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered value.\n * @param {any} value - The value to be rendered.\n * @param {boolean} [shouldClear=true] - Whether to clear the parent before rendering.\n */\nconst renderValue = (parent, value, shouldClear = true) => {\n    if (\n        Array.isArray(value) &&\n        value.length > 0 &&\n        value[0]?._key !== undefined\n    ) {\n        reconcileArray(parent, value);\n        return;\n    }\n    if (shouldClear && !(parent instanceof DocumentFragment)) {\n        while (parent.firstChild) parent.removeChild(parent.firstChild);\n    }\n    if (value == null || value === false) return;\n    if (value._isTemplate) renderTemplate(parent, value);\n    else if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const tempContainer = document.createDocumentFragment();\n            renderValue(tempContainer, value[i], false);\n            parent.appendChild(tempContainer);\n        }\n    } else if (value instanceof Node) parent.appendChild(value);\n    else parent.appendChild(document.createTextNode(String(value)));\n};\n\n/**\n * Renders a template object and its values into a parent DOM node.\n *\n * This function will recursively traverse the template, replacing placeholders\n * with provided values. It will also call any functions that were passed as values\n * and inject the result into the DOM.\n *\n * @param {Node} parent - The parent DOM node that will receive the rendered template.\n * @param {object} templateObject - An object with `template` and `values` properties.\n *     The `template` property should be a template element, and the `values` property\n *     should be an array of values to be inserted into the template.\n */\nconst renderTemplate = (parent, { template, values }) => {\n    const content = template.content.cloneNode(true);\n    let valueIndex = 0;\n\n    const processNode = (node) => {\n        if (\n            node.nodeType === Node.TEXT_NODE &&\n            node.nodeValue.includes(MARKER)\n        ) {\n            const parts = node.nodeValue.split(MARKER);\n            const fragment = document.createDocumentFragment();\n            for (let i = 0; i < parts.length; i++) {\n                if (i > 0) {\n                    const value = values[valueIndex++];\n                    if (typeof value === \"function\") {\n                        const placeholder = document.createElement(\"span\");\n                        fragment.appendChild(placeholder);\n                        effect(() => renderValue(placeholder, value()));\n                    } else {\n                        renderValue(fragment, value, false);\n                    }\n                }\n                if (parts[i])\n                    fragment.appendChild(document.createTextNode(parts[i]));\n            }\n            node.parentNode.replaceChild(fragment, node);\n        } else if (node.nodeType === Node.ELEMENT_NODE) {\n            const attrs = [];\n            for (let i = 0; i < node.attributes.length; i++) {\n                const attr = node.attributes[i];\n                if (attr.name !== \"key\" && attr.value === MARKER)\n                    attrs.push(attr);\n            }\n            for (let i = 0; i < attrs.length; i++) {\n                const attr = attrs[i];\n                const value = values[valueIndex++];\n                node.removeAttribute(attr.name);\n\n                if (attr.name === \"ref\") {\n                    typeof value === \"function\"\n                        ? value(node)\n                        : value &&\n                          typeof value === \"object\" &&\n                          (value.current = node);\n                } else if (\n                    attr.name === \"style\" &&\n                    typeof value === \"object\" &&\n                    value !== null\n                ) {\n                    typeof value === \"function\"\n                        ? effect(() => Object.assign(node.style, value()))\n                        : Object.assign(node.style, value);\n                } else if (\n                    typeof value === \"function\" &&\n                    node.tagName?.includes(\"-\")\n                ) {\n                    node._functionProps ||= {};\n                    node._functionProps[attr.name] = value;\n                } else if (attr.name.startsWith(\"on\")) {\n                    const eventName = attr.name.slice(2).toLowerCase();\n                    if (typeof value === \"function\") {\n                        if (node._cleanup)\n                            node._cleanup(), (node._cleanup = null);\n                        node.addEventListener(eventName, value);\n                        node._cleanup = () =>\n                            node.removeEventListener(eventName, value);\n                    }\n                } else {\n                    const setAttribute = (val) => {\n                        if (\n                            [\"value\", \"checked\", \"selected\"].includes(attr.name)\n                        )\n                            node[attr.name] = val;\n                        else if (val == null || val === false)\n                            node.removeAttribute(attr.name);\n                        else\n                            node.setAttribute(\n                                attr.name,\n                                val === true ? \"\" : val\n                            );\n                    };\n                    typeof value === \"function\"\n                        ? effect(() => setAttribute(value()))\n                        : setAttribute(value);\n                }\n            }\n            node.hasAttribute(\"key\") && node.removeAttribute(\"key\");\n            for (let i = 0; i < node.childNodes.length; i++)\n                processNode(node.childNodes[i]);\n        }\n    };\n\n    for (let i = 0; i < content.childNodes.length; i++) {\n        processNode(content.childNodes[i]);\n    }\n\n    parent.appendChild(content);\n};\n\nexport { renderTemplate, html };\n", "let ctx = null;\nconst LIFECYCLE_HOOKS = [\n    \"beforeMount\",\n    \"mount\",\n    \"beforeUpdate\",\n    \"update\",\n    \"destroy\",\n];\n\n/**\n * Initializes the lifecycle system for a component.\n * @param {object} h - The host component to which the lifecycle is attached.\n * Sets up the lifecycle hooks for the component and defines a method to run\n * these hooks.\n */\nexport const createLifecycle = (h) => {\n    ctx = h;\n    h._lifecycles = Object.fromEntries(LIFECYCLE_HOOKS.map((k) => [k, []]));\n    h.runHook = (k) => {\n        const hooks = h._lifecycles?.[k];\n        hooks?.length &&\n            hooks.forEach((fn) => queueMicrotask(() => fn.call(h)));\n    };\n};\n\n/**\n * Adds a lifecycle hook function to the current component's lifecycle system.\n *\n * @param {string} k - The name of the lifecycle hook.\n * @param {Function} fn - The function to add as a hook.\n * @throws {Error} If called outside of a component's setup phase.\n */\nconst addHook = (k, fn) => {\n    if (!ctx?._lifecycles)\n        throw new Error(`[Esor] Hook called outside ctx setup for \"${k}\"`);\n\n    ctx._lifecycles[k].push(fn);\n};\n\nconst exportedHooks = {};\nLIFECYCLE_HOOKS.forEach((h) => {\n    const fnName = h.startsWith(\"before\")\n        ? h\n        : `on${h[0].toUpperCase()}${h.slice(1)}`;\n    exportedHooks[fnName] = (fn) => addHook(h, fn);\n});\n\n/**\n * Registers an effect function that may return a cleanup function.\n * The cleanup function, if provided, will be registered to run during the \"destroy\" lifecycle phase.\n *\n * @param {Function} fn - The effect function to execute. It may optionally return a cleanup function.\n * @returns {Function} A no-op function.\n */\nexport const onEffect = (fn) => {\n    const cleanup = fn();\n    typeof cleanup === \"function\" && addHook(\"destroy\", cleanup);\n    return () => {};\n};\n\n/**\n * Retrieves the current lifecycle context (component host).\n * This function exposes the internal module-scoped `ctx` variable, which holds\n * the current component instance during its setup phase.\n * @returns {object|null} The current component context, or null if called outside of a component's setup phase.\n * @warning Use with caution. Accessing context outside of a component's synchronous\n * setup phase or in asynchronous contexts can lead to unexpected behavior or retrieving\n * a stale or incorrect context.\n */\nexport const getCurrentContext = () => {\n    !ctx &&\n        console.warn(\"getCurrentContext called outside of component lifecycle\");\n    return ctx;\n};\n\nexport const { beforeMount, onMount, beforeUpdate, onUpdate, onDestroy } =\n    exportedHooks;\n", "const NUM_REGEX = /^-?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?$/;\n\n/**\n * Parses a given attribute value string into an appropriate JavaScript type.\n *\n * - If the value is `null` or `undefined`, returns an empty string.\n * - If the value is the string \"true\", returns the boolean `true`.\n * - If the value is the string \"false\", returns the boolean `false`.\n * - If the value matches the numeric regular expression, returns a `Number`.\n * - If the value is a string that looks like JSON (starts with '{' or '['),\n *   attempts to parse it as JSON and returns the result. If parsing fails,\n *   returns the original string.\n * - Otherwise, returns the original string value.\n *\n * @param {string} v - The attribute value to parse.\n * @returns {any} - The parsed value in an appropriate JavaScript type.\n */\nexport const parseAttributeValue = (v) => {\n    if (v == null) return \"\";\n    if (v === \"true\") return true;\n    if (v === \"false\") return false;\n    if (NUM_REGEX.test(v)) return Number(v);\n    if (typeof v === \"string\" && (v[0] === \"{\" || v[0] === \"[\")) {\n        try {\n            return JSON.parse(v);\n        } catch {}\n    }\n    return v;\n};\n\n/**\n * Initializes properties from attributes of a host element.\n *\n * @param {HTMLElement} h - Element host\n */\nexport const initializeProps = (h) => {\n    h._functionProps && Object.assign(h.props, h._functionProps);\n    for (const { name: n, value: v } of h.attributes) {\n        if (n.startsWith(\"on\") || n.startsWith(\"ref\")) continue;\n        if (v === \"function\" && h._functionProps?.[n]) continue;\n        h.props[n] = parseAttributeValue(v);\n    }\n};\n", "/**\n * Retrieves and caches all style elements and stylesheet links within the document's head.\n *\n * This function selects all <style> elements and <link> elements with a rel attribute\n * of \"stylesheet\" from the document's head section. It caches the results for future\n * use, ensuring that the query is only executed once and subsequent calls return the\n * cached results.\n *\n * @returns {Array} An array of style and link elements representing the stylesheets\n * in the document's head.\n */\nexport const s = () =>\n    (s.cache ||= [\n        ...document.querySelectorAll(\"head style, head link[rel=stylesheet]\"),\n    ]);\n", "import { renderTemplate } from \"./template/render.js\";\nimport { createLifecycle } from \"./lifecycle.js\";\nimport { initializeProps } from \"./props.js\";\nimport { s } from \"./utils/dom.js\";\n\nconst REGEX_TAG_NAME = /^[a-z][a-z0-9]*-[a-z0-9-]*$/;\n\n/**\n * A base class for creating custom elements that provides an API for working\n * with properties, events, and the component lifecycle.\n *\n * @param {function} [setup] An optional function that is called when the\n *     component is initialized. It is passed the component's properties as an\n *     argument and should return a value that can be rendered into the\n *     component's shadow DOM.\n * @param {object} [options] An optional object with options for the component.\n *     Currently only the `mode` option is supported, which can be either\n *     `\"open\"` or `\"closed\"` and determines whether the component's shadow DOM\n *     is open or closed.\n *\n * @returns {class} A class that extends `HTMLElement` and provides the\n *     following additional properties and methods:\n *\n *     - `#shadow`: The component's shadow DOM.\n *     - `props`: An object containing the component's properties.\n *     - `_cleanup`: An array of functions that are called when the component is\n *         destroyed.\n *     - `_isMounted`: A boolean indicating whether the component is currently\n *         mounted.\n *     - `constructor()`: Initializes the component and calls the `setup`\n *         function if it is provided.\n *     - `connectedCallback()`: Called when the component is inserted into the\n *         DOM. It calls the `mount` lifecycle hook if the component is already\n *         mounted.\n *     - `disconnectedCallback()`: Called when the component is removed from the\n *         DOM. It calls the `destroy` lifecycle hook and then calls the\n *         functions in the `_cleanup` array.\n */\nconst BaseComponent = (setup, options = {}) =>\n    class extends HTMLElement {\n        #shadow = this.attachShadow({ mode: options.shadowMode || \"open\" });\n        props = Object.create(null);\n        _cleanup = [];\n\n        constructor() {\n            super();\n            this.#initializeComponent();\n            this.runHook(\"beforeMount\");\n        }\n\n        #initializeComponent() {\n            createLifecycle(this);\n            initializeProps(this);\n            options.globalStyles &&\n                s().forEach((s) => this.#shadow.appendChild(s.cloneNode(true)));\n            const template = setup?.call(this, this.props);\n            renderTemplate(this.#shadow, template);\n        }\n\n        connectedCallback() {\n            this.runHook(\"mount\");\n        }\n        disconnectedCallback() {\n            this._cleanup.forEach((c) => c());\n            this._cleanup = [];\n            this.runHook(\"destroy\");\n        }\n    };\n\n/**\n * Registers a custom element with the specified tag name and setup function.\n *\n * @param {string} tagName The tag name for the custom element. Must be a valid\n *     custom element name according to the custom elements specification.\n * @param {function} [setup] An optional function to initialize the component.\n *     It receives the component's properties and should return a template to be\n *     rendered into the component's shadow DOM.\n * @param {object} [options] Optional configuration for the component.\n *     Supports the `mode` option, which can be `\"open\"` or `\"closed\"`,\n *     determining the accessibility of the component's shadow DOM.\n *\n * @returns {undefined}\n */\nexport const component = (tagName, setup, options = {}) => {\n    typeof customElements !== \"undefined\" &&\n        REGEX_TAG_NAME.test(tagName) &&\n        !customElements.get(tagName) &&\n        customElements.define(tagName, BaseComponent(setup, options));\n};\n", "/**\n * Creates a mutable reference to a value.\n *\n * @param {any} [initialValue=null] - The initial value for the reference.\n * @returns {Function} A getter/setter function for the reference value.\n */\nexport function ref(initialValue = null) {\n    let current = initialValue;\n    return (...v) => (v.length === 0 ? current : (current = v[0]));\n}\n", "/**\n * Emits a custom event with the given name and detail\n * @param {string} name - name of the event\n * @param {*} detail - detail of the event\n * @param {EventTarget} [target=null] - target of the event\n * @returns {CustomEvent} - the emitted event\n */\nexport function emit(name, detail, target = null) {\n    const event = new CustomEvent(name, {\n        detail,\n        bubbles: true,\n        composed: true,\n        cancelable: true,\n    });\n\n    target?.dispatchEvent(event);\n    return event;\n}\n"],
  "mappings": "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",
  "names": ["currentEffect", "batchDepth", "signal", "__name", "initialValue", "value", "subscribers", "args", "newValue", "fn", "effect", "execute", "computed", "result", "batch", "reconcileArray", "parent", "newTemplates", "oldNodesMap", "child", "newNodes", "template", "key", "oldNode", "tempContainer", "renderTemplate", "newNode", "patchNode", "node", "i", "expectedNode", "currentNode", "__name", "oldAttrs", "name", "value", "oldChildren", "newChildren", "maxLen", "oldChild", "newChild", "MARKER", "cache", "html", "__name", "strings", "allValues", "cached", "template", "keyAttrIndex", "s", "key", "otherValues", "renderValue", "parent", "value", "shouldClear", "reconcileArray", "renderTemplate", "i", "tempContainer", "values", "content", "valueIndex", "processNode", "node", "parts", "fragment", "placeholder", "effect", "attrs", "attr", "eventName", "setAttribute", "val", "ctx", "LIFECYCLE_HOOKS", "createLifecycle", "__name", "h", "k", "hooks", "fn", "addHook", "exportedHooks", "fnName", "onEffect", "cleanup", "getCurrentContext", "beforeMount", "onMount", "beforeUpdate", "onUpdate", "onDestroy", "NUM_REGEX", "parseAttributeValue", "__name", "v", "initializeProps", "h", "n", "s", "__name", "REGEX_TAG_NAME", "BaseComponent", "__name", "setup", "options", "_shadow", "_instances", "initializeComponent_fn", "_a", "__privateAdd", "__publicField", "__privateMethod", "c", "createLifecycle", "initializeProps", "s", "__privateGet", "template", "renderTemplate", "component", "tagName", "ref", "initialValue", "current", "v", "__name", "emit", "name", "detail", "target", "event", "__name"]
}
