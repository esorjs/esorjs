<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Esor Demo</title>

    <!-- <script type="module" src="./my-counter.js"></script> -->
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Esor Framework Demo</h1>

        <my-counter></my-counter>

    </div>


    <script type="module">

        // ========== CONSTANTS & SHARED STATE ==========
        const EMPTY_OBJ = Object.freeze(Object.create(null));
        const EMPTY_ARR = Object.freeze([]);
        const NOOP = () => { };
        const NUM_REGEX = /^-?\d+(?:\.\d+)?(?:e[+-]?\d+)?$/;
        const TAG_REGEX = /^[a-z][a-z0-9]*-[a-z0-9-]*$/;
        const MARKER = '\ufeff';
        const NODE_TYPES = { ELEMENT: 1, TEXT: 3, COMMENT: 8 };

        // ========== REACTIVITY CORE ==========
        let current = null;
        let depth = 0;
        let queue = [];
        let queueIndex = 0;

        export const signal = (value) => {
            let v = value;
            const subs = [];

            const s = (newValue) => {
                if (newValue === undefined) {
                    // Getter - optimized dependency tracking
                    if (current && subs.indexOf(current) === -1) {
                        subs.push(current);
                        current.deps?.add(subs);
                    }
                    return v;
                }

                // Setter - optimized with direct comparison
                const next = typeof newValue === 'function' ? newValue(v) : newValue;
                if (v !== next) {
                    v = next;

                    if (depth > 0) {
                        // Batched updates - optimized queue management
                        for (let i = 0; i < subs.length; i++) {
                            const sub = subs[i];
                            if (queue.indexOf(sub) === -1) {
                                queue[queueIndex++] = sub;
                            }
                        }
                    } else {
                        // Direct execution - using classic for loop
                        for (let i = 0; i < subs.length; i++) {
                            subs[i]();
                        }
                    }
                }
                return v;
            };

            return s;
        };

        export const effect = (fn) => {
            const deps = new Set();

            const run = () => {
                // Optimized cleanup
                if (deps.size) {
                    for (const subs of deps) {
                        const idx = subs.indexOf(run);
                        if (idx > -1) subs.splice(idx, 1);
                    }
                    deps.clear();
                }

                current = run;
                current.deps = deps;
                fn();
                current = null;
            };

            run();

            // Return optimized cleanup
            return () => {
                if (deps.size) {
                    for (const subs of deps) {
                        const idx = subs.indexOf(run);
                        if (idx > -1) subs.splice(idx, 1);
                    }
                    deps.clear();
                }
            };
        };

        export const computed = (fn) => {
            let cache;
            let dirty = true;
            const subs = [];

            const compute = () => {
                if (dirty) {
                    // Cleanup old deps
                    if (compute.cleanup) compute.cleanup();

                    // Track new deps
                    const cleanup = effect(() => {
                        cache = fn();
                        dirty = false;

                        // Notify subscribers
                        for (let i = 0; i < subs.length; i++) {
                            subs[i]();
                        }
                    });

                    compute.cleanup = cleanup;
                }

                // Track current as subscriber
                if (current && subs.indexOf(current) === -1) {
                    subs.push(current);
                    current.deps?.add(subs);
                }

                return cache;
            };

            // Mark as dirty when deps change
            const invalidate = () => { dirty = true; };

            return compute;
        };

        export const batch = (fn) => {
            depth++;
            const prevIndex = queueIndex;

            try {
                return fn();
            } finally {
                if (--depth === 0 && queueIndex > prevIndex) {
                    // Execute queued updates
                    const end = queueIndex;
                    queueIndex = 0;

                    for (let i = prevIndex; i < end; i++) {
                        queue[i]();
                        queue[i] = null; // Clear reference
                    }

                    // Reset queue if empty
                    if (queueIndex === 0) {
                        queue.length = 0;
                    }
                }
            }
        };

        // ========== LIFECYCLE MANAGEMENT ==========
        const HOOKS = ['beforeMount', 'mount', 'beforeUpdate', 'update', 'destroy'];
        let lifecycleContext = null;

        const createLifecycle = (host) => {
            lifecycleContext = host;

            // Direct object creation instead of fromEntries
            const lifecycles = host._lifecycles = {
                beforeMount: [],
                mount: [],
                beforeUpdate: [],
                update: [],
                destroy: []
            };

            host.runHook = (key) => {
                const hooks = lifecycles[key];
                if (!hooks || !hooks.length) return;

                // Batch all hooks in single microtask
                if (hooks.length === 1) {
                    queueMicrotask(() => hooks[0].call(host));
                } else {
                    queueMicrotask(() => {
                        for (let i = 0; i < hooks.length; i++) {
                            hooks[i].call(host);
                        }
                    });
                }
            };
        };

        const addHook = (key, fn) => {
            if (!lifecycleContext?._lifecycles) {
                console.error(`[Esor] Hook "${key}" called outside component setup`);
                return;
            }
            lifecycleContext._lifecycles[key].push(fn);
        };

        // Export lifecycle hooks
        export const beforeMount = (fn) => addHook('beforeMount', fn);
        export const onMount = (fn) => addHook('mount', fn);
        export const beforeUpdate = (fn) => addHook('beforeUpdate', fn);
        export const onUpdate = (fn) => addHook('update', fn);
        export const onDestroy = (fn) => addHook('destroy', fn);
        export const onEffect = (fn) => {
            const cleanup = fn();
            if (typeof cleanup === 'function') addHook('destroy', cleanup);
            return NOOP;
        };
        export const getCurrentContext = () => lifecycleContext;

        // ========== DOM UTILITIES ==========
        const createFragment = (nodes, mark = false, parent = null) => {
            if (!nodes?.length) return document.createDocumentFragment();

            const frag = document.createDocumentFragment();
            const stack = [...nodes];

            // Iterative approach instead of recursive
            while (stack.length) {
                const node = stack.pop();
                if (!node) continue;

                if (Array.isArray(node)) {
                    // Add array items to stack in reverse order
                    for (let i = node.length - 1; i >= 0; i--) {
                        stack.push(node[i]);
                    }
                } else {
                    if (mark) node._marker = true;
                    frag.appendChild(node);
                }
            }

            if (parent && frag.childNodes.length) {
                parent.appendChild(frag);
            }

            return frag;
        };

        // Optimized joinTruthy using for loop
        const joinTruthy = (obj) => {
            let result = '';
            for (const key in obj) {
                if (obj[key]) result += key + ' ';
            }
            return result.trim();
        };

        // ========== ATTRIBUTE PARSING ==========
        const parseAttributeValue = (v) => {
            if (v == null) return '';
            if (v === 'true') return true;
            if (v === 'false') return false;
            if (NUM_REGEX.test(v)) return +v; // Unary plus is faster than Number()

            // Only try JSON parse for likely candidates
            if (typeof v === 'string' && (v[0] === '{' || v[0] === '[')) {
                try { return JSON.parse(v); } catch { }
            }

            return v;
        };

        // ========== COMPONENT SYSTEM ==========
        const componentRegistry = new Map();

        export const component = (tagName, setup, options = {}) => {
            if (!TAG_REGEX.test(tagName) || customElements.get(tagName)) return;

            // Cache component class to avoid recreation
            let ComponentClass = componentRegistry.get(tagName);

            if (!ComponentClass) {
                ComponentClass = class extends HTMLElement {
                    constructor() {
                        super();

                        // Use symbols instead of private fields for better performance
                        this.shadow = this.attachShadow({
                            mode: options.shadowMode || 'open'
                        });
                        this.mounted = false;
                        this.props = Object.create(null);
                        this._cleanup = [];

                        // Initialize component
                        this.initComponent();
                        this.runHook('beforeMount');
                    }

                    initComponent() {
                        createLifecycle(this);

                        // Inline event dispatch setup
                        this.emit = (name, detail) => {
                            const event = new CustomEvent(name, {
                                detail,
                                bubbles: true,
                                composed: true,
                                cancelable: true
                            });
                            this.dispatchEvent(event);
                            return event;
                        };

                        // Initialize props from attributes
                        const attrs = this.attributes;
                        for (let i = 0; i < attrs.length; i++) {
                            const { name, value } = attrs[i];
                            if (!name.startsWith('on') && !name.startsWith('ref')) {
                                this.props[name] = signal(parseAttributeValue(value));
                            }
                        }

                        // Call setup and render
                        const result = setup?.call(this, this.props);
                        const content = typeof result === 'function' ? result() : result;
                        createFragment(content || [content], false, this.shadow);
                    }

                    connectedCallback() {
                        if (this.mounted) return;
                        this.mounted = true;
                        this.runHook('mount');
                    }

                    disconnectedCallback() {
                        // Cleanup in single pass
                        const cleanups = this._cleanup;
                        for (let i = 0; i < cleanups.length; i++) {
                            cleanups[i]();
                        }
                        this._cleanup.length = 0;

                        this.runHook('destroy');
                        this.mounted = false;
                    }
                };

                componentRegistry.set(tagName, ComponentClass);
            }

            customElements.define(tagName, ComponentClass);
        };

        // ========== TEMPLATE ENGINE ==========
        const templateCache = new WeakMap();
        const sanitizeMap = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            "'": '&#39;',
            '"': '&quot;'
        };

        const sanitizeHtml = (value) => {
            if (value == null) return '';
            return String(value).replace(/[&<>'"]/g, c => sanitizeMap[c]);
        };

        // Optimized reconciliation
        const reconcile = (newData, marker) => {
            if (!marker?.parentNode) return;

            const parent = marker.parentNode;
            const prevGroups = marker._marker || EMPTY_ARR;

            if (!newData?.length) {
                // Remove all nodes
                for (let i = 0; i < prevGroups.length; i++) {
                    const nodes = prevGroups[i].nodes;
                    for (let j = 0; j < nodes.length; j++) {
                        const node = nodes[j];
                        if (node?.parentNode) {
                            node._cleanup?.();
                            parent.removeChild(node);
                        }
                    }
                }
                marker._marker = EMPTY_ARR;
                return;
            }

            // Build maps for efficient lookup
            const prevMap = new Map();
            for (let i = 0; i < prevGroups.length; i++) {
                prevMap.set(prevGroups[i].key, prevGroups[i]);
            }

            // Process new groups
            const newGroups = new Array(newData.length);
            for (let i = 0; i < newData.length; i++) {
                let nodes = newData[i];
                nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : [nodes];

                // Find key
                let key = null;
                for (let j = 0; j < nodes.length; j++) {
                    if (nodes[j]?.getAttribute?.('key')) {
                        key = nodes[j].getAttribute('key');
                        break;
                    }
                }

                newGroups[i] = { key: key || `_${i}`, nodes };
            }

            // Remove old nodes
            for (let i = 0; i < prevGroups.length; i++) {
                const group = prevGroups[i];
                let found = false;

                for (let j = 0; j < newGroups.length; j++) {
                    if (newGroups[j].key === group.key) {
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    const nodes = group.nodes;
                    for (let j = 0; j < nodes.length; j++) {
                        const node = nodes[j];
                        if (node?.parentNode) {
                            node._cleanup?.();
                            parent.removeChild(node);
                        }
                    }
                }
            }

            // Update/insert nodes
            let lastNode = marker;
            for (let i = 0; i < newGroups.length; i++) {
                const newGroup = newGroups[i];
                const prevGroup = prevMap.get(newGroup.key);

                if (prevGroup) {
                    patchNodes(prevGroup.nodes, newGroup.nodes, parent);

                    // Move if needed
                    if (prevGroup.nodes[0] !== lastNode.nextSibling) {
                        const frag = document.createDocumentFragment();
                        for (let j = 0; j < prevGroup.nodes.length; j++) {
                            frag.appendChild(prevGroup.nodes[j]);
                        }
                        parent.insertBefore(frag, lastNode.nextSibling);
                    }

                    newGroup.nodes = prevGroup.nodes;
                } else {
                    const frag = createFragment(newGroup.nodes, true);
                    parent.insertBefore(frag, lastNode.nextSibling);
                }

                const groupNodes = newGroup.nodes;
                lastNode = groupNodes[groupNodes.length - 1] || lastNode;
            }

            marker._marker = newGroups;
        };

        // Optimized node patching
        const patchNodes = (prevNodes, nextNodes, parent) => {
            const maxLen = Math.max(prevNodes.length, nextNodes.length);

            for (let i = 0; i < maxLen; i++) {
                const prev = prevNodes[i];
                const next = nextNodes[i];

                if (!prev && next) {
                    parent.appendChild(next);
                } else if (prev && !next) {
                    prev._cleanup?.();
                    parent.removeChild(prev);
                } else if (prev && next) {
                    if (prev.nodeType !== next.nodeType || prev.tagName !== next.tagName) {
                        parent.replaceChild(next, prev);
                    } else if (prev.nodeType === NODE_TYPES.TEXT) {
                        if (prev.nodeValue !== next.nodeValue) {
                            prev.nodeValue = next.nodeValue;
                        }
                    } else if (prev.nodeType === NODE_TYPES.ELEMENT) {
                        patchAttributes(prev, next);
                        patchNodes(
                            Array.from(prev.childNodes),
                            Array.from(next.childNodes),
                            prev
                        );
                    }
                }
            }
        };

        // Optimized attribute patching
        const patchAttributes = (elem, next) => {
            const prevAttrs = elem.attributes;
            const nextAttrs = next.attributes;
            const seen = new Set();

            // Update/add attributes
            for (let i = 0; i < nextAttrs.length; i++) {
                const { name, value } = nextAttrs[i];
                if (elem.getAttribute(name) !== value) {
                    elem.setAttribute(name, value);
                }
                seen.add(name);
            }

            // Remove old attributes
            for (let i = prevAttrs.length - 1; i >= 0; i--) {
                const name = prevAttrs[i].name;
                if (!seen.has(name)) {
                    elem.removeAttribute(name);
                }
            }
        };

        // Template processing
        const processTemplate = (template, data) => {
            const content = template.content;
            const walker = document.createTreeWalker(content, NODE_TYPES.ELEMENT | NODE_TYPES.TEXT);

            let node;
            let dataIndex = 0;

            while (node = walker.nextNode()) {
                if (node.nodeType === NODE_TYPES.ELEMENT && node.attributes.length) {
                    const attrs = Array.from(node.attributes);

                    for (let i = 0; i < attrs.length; i++) {
                        const attr = attrs[i];
                        if (attr.value === MARKER) {
                            render(node, attr.name, data[dataIndex++]);
                        }
                    }
                } else if (node.nodeType === NODE_TYPES.TEXT && node.nodeValue.includes(MARKER)) {
                    if (node.nodeValue === MARKER) {
                        const comment = document.createComment('');
                        node.parentNode.replaceChild(comment, node);
                        render(comment, null, data[dataIndex++]);
                    } else {
                        // Split and process text with markers
                        const parts = node.nodeValue.split(MARKER);
                        const fragment = document.createDocumentFragment();

                        for (let i = 0; i < parts.length; i++) {
                            if (i > 0) {
                                const comment = document.createComment('');
                                fragment.appendChild(comment);
                                render(comment, null, data[dataIndex++]);
                            }

                            if (parts[i]) {
                                fragment.appendChild(document.createTextNode(parts[i]));
                            }
                        }

                        node.parentNode.replaceChild(fragment, node);
                    }
                }
            }
        };

        // Optimized render function
        const render = (node, attr, value) => {
            if (attr) {
                node.removeAttribute(attr);

                if (attr === 'ref') {
                    if (typeof value === 'function') {
                        value(node);
                    } else if (value) {
                        value.current = node;
                    }
                } else if (attr.startsWith('on') && typeof value === 'function') {
                    const eventName = attr.slice(2).toLowerCase();
                    node.addEventListener(eventName, value);
                    node._cleanup = () => node.removeEventListener(eventName, value);
                } else if (attr === 'style' && typeof value === 'object') {
                    effect(() => Object.assign(node.style, value));
                } else {
                    effect(() => {
                        const val = typeof value === 'function' ? value() : value;
                        setAttribute(node, attr, val);
                    });
                }
            } else {
                setContent(node, value);
            }
        };

        // Optimized attribute setting
        const setAttribute = (node, attr, value) => {
            if (attr === 'value' || attr === 'checked') {
                node[attr] = value;
            } else if (value === false || value == null) {
                node.removeAttribute(attr);
            } else {
                node.setAttribute(
                    attr,
                    typeof value === 'object' ? joinTruthy(value) : value
                );
            }
        };

        // Optimized content setting
        const setContent = (node, value) => {
            const update = (val) => {
                if (val === true || val === false) val = '';

                if (Array.isArray(val)) {
                    reconcile(val, node);
                } else {
                    const textValue = val == null ? '' : String(val);
                    const textNode = document.createTextNode(sanitizeHtml(textValue));

                    // Replace all following nodes until next marker
                    let next = node.nextSibling;
                    while (next && next._marker) {
                        const toRemove = next;
                        next = next.nextSibling;
                        toRemove._cleanup?.();
                        toRemove.parentNode.removeChild(toRemove);
                    }

                    // Insert new text node
                    const parent = node.parentNode;
                    parent.insertBefore(textNode, node.nextSibling);
                    textNode._marker = true;
                }
            };

            if (typeof value === 'function') {
                effect(() => update(value()));
            } else {
                update(value);
            }
        };

        // Main html template function
        export const html = (strings, ...values) => {
            let cached = templateCache.get(strings);

            if (!cached) {
                cached = strings;
                templateCache.set(strings, cached);
            }

            // No interpolation - return static nodes
            if (!values.length) {
                const template = document.createElement('template');
                template.innerHTML = cached.join('');
                return Array.from(template.content.childNodes);
            }

            // Build template with markers
            const template = document.createElement('template');
            template.innerHTML = cached.join(MARKER);

            processTemplate(template, values);

            return Array.from(template.content.childNodes);
        };

        // ========== UTILITIES ==========
        export const ref = (initialValue = null) => {
            let value = initialValue;
            return (newValue) => newValue !== undefined ? (value = newValue) : value;
        };

        export const emit = (name, detail, target = null) => {
            const event = new CustomEvent(name, {
                detail,
                bubbles: true,
                composed: true,
                cancelable: true
            });

            (target || document).dispatchEvent(event);
            return event;
        };




        component("my-counter", () => {
            const count = signal(0);
            const increment = () => {
                count(count() + 1);
                console.log('Count updated:', count());
            };


            return html`
            <div>
                <h2>My Counter</h2>
                <p>Count: ${count}</p>
                <button onclick=${increment}>Increment</button>
                <button onclick=${() => count(count() - 1)}>Decrement</button>
                <button onclick=${() => count(0)}>Reset</button>
            </div>
        `;
        });

    </script>

</body>

</html>