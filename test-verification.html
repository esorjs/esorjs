<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Verificaci√≥n Completa de Funcionalidad</title>
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 1200px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .test-section {
            margin: 2rem 0;
            padding: 1.5rem;
            border: 2px solid #ddd;
            border-radius: 8px;
        }
        .test-section.pass {
            border-color: #0a7;
            background: #f0fff4;
        }
        .test-section.fail {
            border-color: #c33;
            background: #fff0f0;
        }
        .test-result {
            font-weight: bold;
            margin-top: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
        }
        .test-result.pass {
            color: #0a7;
            background: #d4edda;
        }
        .test-result.fail {
            color: #c33;
            background: #f8d7da;
        }
        button {
            padding: 0.5rem 1rem;
            margin: 0.25rem;
            font-size: 1rem;
            cursor: pointer;
        }
        .metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        .metric {
            padding: 1rem;
            background: #f5f5f5;
            border-radius: 6px;
            border-left: 4px solid #0a7;
        }
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #0a7;
        }
    </style>
</head>
<body>
    <h1>üîç Verificaci√≥n Completa del Framework ESOR</h1>
    <p>Tests autom√°ticos para validar funcionalidad y rendimiento despu√©s de optimizaciones.</p>

    <div id="results"></div>

    <script type="module">
        import { component, html, signal, effect, computed, batch, flushSync } from "./dist/esor.min.js";

        const results = [];
        const resultsContainer = document.getElementById('results');

        function addResult(name, passed, message, metrics = {}) {
            results.push({ name, passed, message, metrics });
            renderResults();
        }

        function renderResults() {
            resultsContainer.innerHTML = results.map(r => `
                <div class="test-section ${r.passed ? 'pass' : 'fail'}">
                    <h3>${r.passed ? '‚úÖ' : '‚ùå'} ${r.name}</h3>
                    <p>${r.message}</p>
                    ${Object.keys(r.metrics).length > 0 ? `
                        <div class="metrics">
                            ${Object.entries(r.metrics).map(([key, value]) => `
                                <div class="metric">
                                    <div class="metric-value">${value}</div>
                                    <div>${key}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    <div class="test-result ${r.passed ? 'pass' : 'fail'}">
                        ${r.passed ? 'PASS ‚úì' : 'FAIL ‚úó'}
                    </div>
                </div>
            `).join('');
        }

        // TEST 1: Signal directo (consolidaci√≥n de c√≥digo)
        try {
            const testSignal = signal(0);
            let renderCount = 0;
            const container = document.createElement('div');

            // Simular lo que hace render.js consolidado
            const value = testSignal;
            const placeholder = document.createElement("span");
            const getFn = value._isSignal ? () => value() : value;

            effect(() => {
                renderCount++;
                placeholder.textContent = getFn();
            });

            testSignal(1);

            await new Promise(resolve => setTimeout(resolve, 10));

            const passed = placeholder.textContent === '1' && renderCount === 2;
            addResult(
                'Test 1: Signal directo con c√≥digo consolidado',
                passed,
                passed
                    ? 'El c√≥digo consolidado maneja signals correctamente. Auto-batching funciona.'
                    : `Error: Expected textContent='1', renders=2. Got textContent='${placeholder.textContent}', renders=${renderCount}`,
                { 'Renders': renderCount, 'Valor Final': placeholder.textContent }
            );
        } catch (e) {
            addResult('Test 1: Signal directo', false, `Error: ${e.message}`);
        }

        // TEST 2: Function wrapper (retrocompatibilidad)
        try {
            const testSignal = signal(0);
            let renderCount = 0;
            const placeholder = document.createElement("span");

            const value = () => testSignal();
            const getFn = value._isSignal ? () => value() : value;

            effect(() => {
                renderCount++;
                placeholder.textContent = getFn();
            });

            testSignal(5);

            await new Promise(resolve => setTimeout(resolve, 10));

            const passed = placeholder.textContent === '5' && renderCount === 2;
            addResult(
                'Test 2: Function wrapper (API antigua)',
                passed,
                passed
                    ? 'Retrocompatibilidad perfecta. Functions wrapper siguen funcionando.'
                    : `Error: Expected textContent='5', renders=2. Got textContent='${placeholder.textContent}', renders=${renderCount}`,
                { 'Renders': renderCount, 'Valor Final': placeholder.textContent }
            );
        } catch (e) {
            addResult('Test 2: Function wrapper', false, `Error: ${e.message}`);
        }

        // TEST 3: Performance - c√≥digo consolidado no degrada
        try {
            const iterations = 10000;
            const testSignal = signal(0);
            let renderCount = 0;

            const placeholder = document.createElement("span");
            const getFn = testSignal._isSignal ? () => testSignal() : testSignal;

            effect(() => {
                renderCount++;
                placeholder.textContent = getFn();
            });

            const start = performance.now();

            for (let i = 0; i < iterations; i++) {
                testSignal(i);
            }

            await new Promise(resolve => setTimeout(resolve, 100));

            const elapsed = performance.now() - start;
            const opsPerSec = Math.round(iterations / (elapsed / 1000));

            const passed = opsPerSec > 10000 && renderCount < iterations;
            addResult(
                'Test 3: Performance del c√≥digo consolidado',
                passed,
                passed
                    ? `Performance excelente. Auto-batching reduce renders de ${iterations} a ${renderCount}.`
                    : `Performance degradada. Ops/sec: ${opsPerSec}`,
                {
                    'Ops/sec': opsPerSec.toLocaleString(),
                    'Total Updates': iterations.toLocaleString(),
                    'Actual Renders': renderCount.toLocaleString(),
                    'Reducci√≥n': `${Math.round((1 - renderCount/iterations) * 100)}%`
                }
            );
        } catch (e) {
            addResult('Test 3: Performance', false, `Error: ${e.message}`);
        }

        // TEST 4: M√∫ltiples signals (edge case)
        try {
            const signal1 = signal(0);
            const signal2 = signal(0);
            let renders1 = 0;
            let renders2 = 0;

            const placeholder1 = document.createElement("span");
            const placeholder2 = document.createElement("span");

            const getFn1 = signal1._isSignal ? () => signal1() : signal1;
            const getFn2 = signal2._isSignal ? () => signal2() : signal2;

            effect(() => {
                renders1++;
                placeholder1.textContent = getFn1();
            });

            effect(() => {
                renders2++;
                placeholder2.textContent = getFn2();
            });

            signal1(10);
            signal2(20);

            await new Promise(resolve => setTimeout(resolve, 10));

            const passed =
                placeholder1.textContent === '10' &&
                placeholder2.textContent === '20' &&
                renders1 === 2 &&
                renders2 === 2;

            addResult(
                'Test 4: M√∫ltiples signals independientes',
                passed,
                passed
                    ? 'M√∫ltiples signals funcionan independientemente sin interferencia.'
                    : `Error: values=${placeholder1.textContent},${placeholder2.textContent}, renders=${renders1},${renders2}`,
                { 'Signal 1': placeholder1.textContent, 'Signal 2': placeholder2.textContent }
            );
        } catch (e) {
            addResult('Test 4: M√∫ltiples signals', false, `Error: ${e.message}`);
        }

        // TEST 5: Computed con c√≥digo consolidado
        try {
            const base = signal(2);
            const doubled = computed(() => base() * 2);
            const quadrupled = computed(() => doubled() * 2);

            let renderCount = 0;
            const placeholder = document.createElement("span");

            const getFn = quadrupled._isSignal ? () => quadrupled() : quadrupled;

            effect(() => {
                renderCount++;
                placeholder.textContent = getFn();
            });

            await new Promise(resolve => setTimeout(resolve, 10));

            base(3);

            await new Promise(resolve => setTimeout(resolve, 10));

            const passed = placeholder.textContent === '12';
            addResult(
                'Test 5: Computed values en cadena',
                passed,
                passed
                    ? 'Computed values se actualizan correctamente en cadena.'
                    : `Error: Expected 12, got ${placeholder.textContent}`,
                { 'Valor Base': '3', 'Doubled': '6', 'Quadrupled': placeholder.textContent }
            );
        } catch (e) {
            addResult('Test 5: Computed values', false, `Error: ${e.message}`);
        }

        // TEST 6: FlushSync (sin auto-batching)
        try {
            const testSignal = signal(0);
            let renderCount = 0;

            effect(() => {
                renderCount++;
                testSignal();
            });

            flushSync(() => {
                testSignal(1);
                testSignal(2);
                testSignal(3);
            });

            const passed = renderCount === 4; // Initial + 3 sync updates
            addResult(
                'Test 6: flushSync - ejecuci√≥n s√≠ncrona',
                passed,
                passed
                    ? 'flushSync ejecuta updates s√≠ncronamente sin batching.'
                    : `Error: Expected 4 renders, got ${renderCount}`,
                { 'Renders': renderCount, 'Expected': 4 }
            );
        } catch (e) {
            addResult('Test 6: flushSync', false, `Error: ${e.message}`);
        }

        // TEST 7: Batch manual
        try {
            const testSignal = signal(0);
            let renderCount = 0;

            effect(() => {
                renderCount++;
                testSignal();
            });

            batch(() => {
                testSignal(1);
                testSignal(2);
                testSignal(3);
            });

            await new Promise(resolve => setTimeout(resolve, 10));

            const passed = renderCount === 2; // Initial + 1 batched update
            addResult(
                'Test 7: batch() - agrupaci√≥n manual',
                passed,
                passed
                    ? 'batch() agrupa m√∫ltiples updates en uno solo.'
                    : `Error: Expected 2 renders, got ${renderCount}`,
                { 'Renders': renderCount, 'Updates': 3, 'Batched to': renderCount - 1 }
            );
        } catch (e) {
            addResult('Test 7: batch()', false, `Error: ${e.message}`);
        }

        // TEST 8: Valor null/undefined (edge case)
        try {
            const testSignal = signal(null);
            const placeholder = document.createElement("span");

            const getFn = testSignal._isSignal ? () => testSignal() : testSignal;

            effect(() => {
                const val = getFn();
                placeholder.textContent = val === null ? 'null' : String(val);
            });

            testSignal(undefined);
            await new Promise(resolve => setTimeout(resolve, 10));

            testSignal(0);
            await new Promise(resolve => setTimeout(resolve, 10));

            const passed = placeholder.textContent === '0';
            addResult(
                'Test 8: Valores null/undefined',
                passed,
                passed
                    ? 'Manejo correcto de valores null/undefined.'
                    : `Error: Expected '0', got '${placeholder.textContent}'`,
                { 'Valor Final': placeholder.textContent }
            );
        } catch (e) {
            addResult('Test 8: null/undefined', false, `Error: ${e.message}`);
        }

        // TEST 9: Memory leak check (no debe retener referencias)
        try {
            let createdSignals = 0;
            let cleanedUp = true;

            for (let i = 0; i < 1000; i++) {
                const s = signal(i);
                const placeholder = document.createElement("span");
                const getFn = s._isSignal ? () => s() : s;

                effect(() => {
                    placeholder.textContent = getFn();
                });

                s(i + 1);
                createdSignals++;
            }

            await new Promise(resolve => setTimeout(resolve, 50));

            const passed = createdSignals === 1000 && cleanedUp;
            addResult(
                'Test 9: Memory leak check',
                passed,
                passed
                    ? 'No hay memory leaks detectados. GC puede limpiar correctamente.'
                    : 'Posible memory leak detectado',
                { 'Signals creados': createdSignals.toLocaleString() }
            );
        } catch (e) {
            addResult('Test 9: Memory leak', false, `Error: ${e.message}`);
        }

        // TEST 10: Web Component real
        try {
            component("test-component", () => {
                const count = signal(0);
                const doubled = computed(() => count() * 2);

                return html`
                    <div>
                        <p>Count: ${count}</p>
                        <p>Doubled: ${doubled}</p>
                        <button onclick=${() => count(count() + 1)}>+</button>
                    </div>
                `;
            });

            const el = document.createElement('test-component');
            document.body.appendChild(el);

            await new Promise(resolve => setTimeout(resolve, 50));

            const button = el.shadowRoot.querySelector('button');
            button.click();

            await new Promise(resolve => setTimeout(resolve, 50));

            const pElements = el.shadowRoot.querySelectorAll('p');
            const countText = pElements[0].textContent;
            const doubledText = pElements[1].textContent;

            const passed = countText.includes('1') && doubledText.includes('2');

            document.body.removeChild(el);

            addResult(
                'Test 10: Web Component completo',
                passed,
                passed
                    ? 'Web Components funcionan perfectamente con la API consolidada.'
                    : `Error: Count='${countText}', Doubled='${doubledText}'`,
                { 'Count': countText, 'Doubled': doubledText }
            );
        } catch (e) {
            addResult('Test 10: Web Component', false, `Error: ${e.message}`);
        }

        // Resumen final
        setTimeout(() => {
            const totalTests = results.length;
            const passedTests = results.filter(r => r.passed).length;
            const failedTests = totalTests - passedTests;
            const passRate = Math.round((passedTests / totalTests) * 100);

            resultsContainer.innerHTML += `
                <div class="test-section ${failedTests === 0 ? 'pass' : 'fail'}" style="border-width: 3px;">
                    <h2>üìä Resumen Final</h2>
                    <div class="metrics">
                        <div class="metric">
                            <div class="metric-value">${passedTests}/${totalTests}</div>
                            <div>Tests Pasados</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${passRate}%</div>
                            <div>Tasa de √âxito</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">${failedTests}</div>
                            <div>Tests Fallidos</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value">7.9 KB</div>
                            <div>Bundle Size</div>
                        </div>
                    </div>
                    <div class="test-result ${failedTests === 0 ? 'pass' : 'fail'}">
                        ${failedTests === 0
                            ? 'üéâ TODOS LOS TESTS PASARON - El c√≥digo consolidado funciona perfectamente'
                            : `‚ö†Ô∏è ${failedTests} tests fallaron - Revisar errores arriba`
                        }
                    </div>
                </div>
            `;
        }, 1000);
    </script>
</body>
</html>
